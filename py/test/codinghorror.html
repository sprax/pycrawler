Why Can't Programmers.. Program?
After a fair bit of trial and error I've discovered that people who struggle to code don't just struggle on big problems or even smallish problems (i.
So I set out to develop questions that can identify this kind of developer and came up with a class of questions I call "FizzBuzz Questions" named after a game children often play (or are made to play) in schools in the UK.
Write a program that prints the numbers from 1 to 100.
But for multiples of three print "Fizz" instead of the number and for the multiples of five print "Buzz".
For numbers which are multiples of both three and five print "FizzBuzz".
Most good programmers should be able to write out on paper a program which does this in a under a couple of minutes.
The majority of comp sci graduates can't.
PhDs in computer science fail during interviews when asked to carry out basic programming tasks.
Less trivially I've interviewed many candidates who can't use recursion to solve a real problem.
These are basic skills; anyone who lacks them probably hasn't done much programming.
Speaking on behalf of software engineers who have to interview prospective new hires I can safely say that we're tired of talking to candidates who can't program their way out of a paper bag.
Between Reginald Dan and Imran I'm starting to get a little worried.
Everybody has to start somewhere.
Apparently this is not a reasonable assumption to make.
At Vertigo we require a code sample before we even proceed to the phone interview stage.
And our on-site interview includes a small coding exercise.
Nothing difficult mind you just a basic exercise to go through the motions of building a small application in an hour or so.
Although there have been one or two notable flame-outs for the most part this strategy has worked well for us.
Due to high volume comments for this entry are now closed.
In case any readers don't know how to complete that test here's a solution in VBScript.
To try it - save the code into "c:\test.
VBA job (yes you can stop booing for the peanut gallery) whom I asked to swap two variable contents without using a temp variable.
Well I can't do it in VBA but if you let me use Excel I can put the values in two cells and swap the cells' contents using a third cell.
We hired the guy who said well "if they're integers then I'd do it by a=a|b b=a^b a=a^b.
But I don't know how to do it if they're strings.
However I have never *once* used - or had call to use - recursion to solve a problem since I learned about it at university.
The most obvious way to decide - for me - is to run through these tests emply the person you like the best and then look at the code they've produced after a week.
The bottom line is you can always learn to pass interview tests of any kind - that doesn't mean you can program or not.
OK you have to care about line breaks which I don't know in VBS (never used that crap thank goodness).
As a web developer I also have very little cause to use it.
The only time I use it is when I need to search through the file system.
Where I work we spend a long time looking before we hire someone because it's so hard to find them.
Unfortunately that wouldn't be a valid solution (in VBScript) because WScript.
In another language it might work though.
Sorry but if someone were to ask me how to swap two variables w/o a temp variable I'd ask them to give me a good reason why.
Not being able to answer that particular question certainly doesn't preclude someone from being a good programmer.
Why the hell would they need to know that and how does that help you determine that they understand the ASP.
As you point out your solution doesn't handle line breaks.
He was picking up about GBP400 a day (call it about $650 at that time) for this.
If we get that far I can find out if we agree on why it's good.
On the other hand do you want an ASP.
Can you really call the candidate who only knows ASP.
Net but nothing about a basic logic a programmer (or a computer scientist or a software engineer or a coder) or is he just some guy who knows ASP.
The whole point of the article is about WHY we have to ask people to write FizzBuzz.
The mechanical part of writing and solving FizzBuzz is irrelevant.
Any programmer who cares enough to read programming blogs is already far beyond such a simple problem.
My point is that what you're asking for isn't "domain knowledge" strictly speaking.
Using an XOR to swap two variables w/o a temp variable is only really useful when memory is expensive (embedded programming et al).
The first time I ever encountered that I was writing a Perlin Noise Generator based off of someone else's work.
Outside of routines that need to be highly optimized there's no reason for it.
Granted the XOR trick is pretty well known but not knowing it off the top of your head says nothing about your abilities as a programmer (whereas the fizzbuzz example does).
IT person but not someone who is interviewing programmers.
And the Googler might be after the solution).
Interestingly the use of a technical test in interviews can actually work both ways.
In my recent hunt for a new job I automatically turned down any vacancy where I was *not* given a technical test.
The harder the test I was given the more excited I was about the vacancy.
If anyone out there is looking for a new job I urge you to bear that in mind.
Instead of using recursion it's often faster to use a Stack.
Survivor for Developers' for those who don't make the cut.
At the end of each week you vote the worst dev off the island.
Most people are terrified/stressed out during interviews.
However I have never *once* used - or had call to use - recursion to solve a problem since I learned about it at university.
Damnd thing took me three minutes to write in php.
It is amazing how many people are paid to be programmers that struggle at the job and clearly should have been hired in the first place.
When I used to teach college I noticed the same trend.
CS student just really did not understand how to program.
Having in the past been tortured by clueless candidates I can believe the claim.
Phone screening with simple as simple can be questions is amazingly (and disturbingly) effective.
While you may not have used recursion to solve a problem if you know what it is and how to code something simple then that is enough me thinks.
There is a stunningly large population of people who describe themselves as 'professional software developers' who have not the faintest idea about recursion bit masking hexadecimal maths.
Over the years I've built up a loose theory on these "pretenders"--they are the people that know tinker and tweak and copy and paste and fidle and when left alone for a while some how manage to produce a bit of code that passes as productive.
Non technical people just cannot distinguish between them and us and many times we technical people don't ask the right questions.
Surely it varies but inevitably we are asking questions whose answers have nothing to do with problem solving and the mechanics of coding.
One of my FizzBuzz questions is when a candidate has "SQL" on their CV is to draw a simple table (Person: last first sex DoB) populate it with four or five rows and ask them to write some SQL that returns all the males or everyone born after a given date.
Simple enough problem very real world and relevant to someone working in 'web development'.
Our profession is full of frauds and incompetent fools.
And I feel safe saying that here because if you are reading the comments on Jeff's blog then you actually take an interest in both the nitty gritty of computers and programming.
The majority of comp sci graduates can’t.
Ofcourse we all know that being a elite programmer is all about how fast you can program especially in a high-pressure situation.
Most development is simple viewing and editing of data in forms.
Developers who can't write "fizzbuzz" can be productive in such an environment especially if there is existing code they can copy and modify.
Most development is simple viewing and editing of data in forms.
Developers who can't write "fizzbuzz" can be productive in such an environment especially if there is existing code they can copy and modify.
Most development is simple viewing and editing of data in forms.
Developers who can't write "fizzbuzz" can be productive in such an environment especially if there is existing code they can copy and modify.
If fizzbuzz is beyond them concepts such as memory/processor usage security stability defensive programming etc.
Unchecked inputs error messages that consisted solely of dancing cats (seriously) SQL and HTML injection holes all over the place.
On writing a program to switch two variables without a temporary variable; while I had a hunch it involved bit operations of some kind I certainly wouldn't know how to do it off hand.
On time taken to program; I'd probably spend several minutes just staring the FizzBuzz task looking for some complexity I'd missed so that's also something to take into account.
Back in '99 I was given a FizzBuzz task by a Microsoft recruiter to design a program that would take two inputs and determine if they were anagrams of each other.
He was very impressed that I would start with such a test.
Seems most people would go through cycles and cycles regardless of the inputs.
To be honest as a recent grad and somone who is new to being a software developer I think if you are incompetant you shouldn't last long anyway.
In my first month at my new job I had to learn VB and C++ from scratch two months later I was moved on to a project in C# using ASP.
Net which I'd never used before.
My current employer gave me 3 hours to parse an XMl file and display it as a tree structure.
XML before but with after a quick google for a reference on the SAX api I was coding away.
IDE and insisted on using a text editor.
Another couple of employers has written tests with small "write a code fragment to do this" and "spot the mistake in this code" questions.
Job becuase I took an API I had never used before and figured out how to use it.
University is not an excercise in cramming your head full of knowledge it's an excercise in learning how to learn quickly and efficiently.
When you know the basics you can teach yourself a new language in a few hours and depending on the complexity learn a new API in an hour to day.
Many grads I find dont have that capacity I did a masters with a bunch of people who came from different universities to me and some of them just couldn't cope with having to fend for them selves.
Stu Thompson wrote "There is a stunningly large population of people who describe themselves as 'professional software developers' who have not the faintest idea about recursion bit masking hexadecimal maths.
FizzBuzz sure any programmer should know how to write that.
That example just goes to show the wide range of expertise involved in programming not all of which is required to be a successful or skilled programmer.
But Stu goes on to say talk about asking for SQL examples in interviews and here not only would I be able to demonstrate inserts and updates - of course - but left joins cross joins multi-table deletes whatever.
FizzBuzz is an acceptable test because it is non-domain specific the same cannot be said for all other types of programming knowledge.
Granted the XOR trick is pretty well known but not knowing it off the top of your head says nothing about your abilities as a programmer (whereas the fizzbuzz example does).
The majority of CS grads can handle the trivial stuff like "FizzBuzz" (though a slight majority probably never really grokked recursion).
This person didn't know the integrated debugger existed.
No their method of debugging was to randomly change stuff to see if it fixed their problem.
Not surprisingly that didn't work very well.
However it doesnt fulfill the specification.
Write a program that prints the numbers from 1 to 100.
But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”.
For numbers which are multiples of both three and five print “FizzBuzz”.
COTS version of the FizzBuzz application.
Makes one really start to question the worth of such statements as "if you're reading this blog you're already much better than those *other* programmers".
And did you really think you could say "only 0.
University course the teacher asking how many people never programmed before.
Many hands were raised and I felt bad for them for choosing a future profession without knowning what it actually was about.
Then he asked how many people never touched a keyboard before.
How shock was I to see at least 10 persons raise their hand mostly women.
There really isn't a good use case for it anymore (its not even necessarily faster than using a temp since procs have so many registers these days).
Besides your solution of a=a+b b=a-b a=a-b fails in overflow cases.
XOR solution is more correct but still unnecessary.
Then I read the first chapter of Structure and Interpretation of Computer Programs and some other stuff about writing compilers and interpreters.
Now I use recursion all the time coming up with all sorts of general automated solutions for the sorts of tedious tasks I used to code out by hand.
Because demand for good programmers has outstripped supply.
Those of us who interview a lot of applicants (I've seen at least 50 the last year) know two things: most can't program and those who can will be tough to get.
And now it's been bad enough for long enough that many doing the hiring can't program either so screening is often incompetent and these charlatans stand an excellent chance of getting hired anyway.
Testing is imperative but some just seem reluctant to do it -- it seems so cold and mean.
Fizzbuzz looks like a good test.
Here are two other standard questions the first one broadly published and the second very general.
Say that for each card there is a letter on one side and a number on the other side.
When the applicant doesn't know what a vowel is or a hash table is I know it's going to be a long day.
Jeff just wants us to fell all fuzzy and warm.
My point is that the many 'programmers' do not know *anything* about bit masking *and* other core concepts.
Good for you on the SQL but then again it is domain specific and I qualified it as such above.
You should have declared 5 and 3 constants and used the constants in your code.
Besides real programmers wouldn't program in VB they'd use Perl.
Now if I can only get this page to work in my Lynx web browser.
Ugh had one of those on Friday.
Our caching system was spitting out the wrong data (by which I mean the wrong user's data).
Never showed up on the dev system because the caching system uses SoftReferences to allow the Java garbage collector to expire data from it and the dev version never ran long enough for garbage collection to really be an issue.
Important lesson about being _really_ sure about your compareTo() methods before using java.
Took us 40 minutes to locate fix and patch to live.
Which is a little longer than usual but locating the problem more or less came down to eliminating everything it couldn't be then figuring out how it was the fault of what was left.
Geez guys - EVERY ONE of you who gave example code - EVERY ONE - hard coded the FIZZ and BUZZ conditions.
And a LOT of you wrote code that will do the FIZZ BUZZ and FIZZBUZZ but NOT print the integer.
And yes it's as dirty as it would ever get .
My biggest problem with solving simple programming problems tends to be the memorization involved with different languages especially if I haven't used a particular language in a while.
More often than not I'll go through my resume and remove (or limit mention of) languages that I used for only a short time or simply haven't used in a while.
For example I feel quite competant with dealing with basic database issues but without having touched a database in a few years I'd have to look up even the most basic sql statements so I wouldn't claim to be a capable database programmer though after a couple of weeks I could be at least a moderately good one.
Recursion is a similar problem with different languages.
Some languages don't allow it at all and others have very specific restrictions that make it a little harder to just jump in and say we'll just make this call here and make sure the conditions are in line to stop the whole mess from self-destructing.
In other words I have a terrible memory but I can still answer most of those questions with whatever language I've been using recently.
And did you really think you could say "only 0.
When I started my first job after university (also my first programming job) I could /maybe/ have answered FizzBuzz in Java.
Two months later I was improving my colleagues' code in a language I'd never used before.
Ofcourse we all know that being a elite programmer is all about how fast you can program especially in a high-pressure situation.
In most languages using a stack instead of recursion speeds up your app tremendously.
If so I apologize but I fail to see what exactly I did to you.
Any question can be made difficult.
If asked an easy question an interviewee knows they have to get it right and will become more nervous as time goes on.
Over the course of three minutes it can get *very* bad.
Write a program that prints the numbers from 1 to 100.
But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”.
For numbers which are multiples of both three and five print “FizzBuzz”.
The interviewee may be trying to remember how mod is implemented.
And thinking about fence posts.
And thinking about 3 cases of control flow.
And why they're being asked this stupid question.
Normally you do not deal with all of these things at the same time but asking a simple question in a stressful environment in which the interviewee is getting ready to put 110% in to whatever you say will likely lead them in to trying to do so.
As you get more nervous (because the question is taking a long time) your nervousness will feed into itself.
Asking insightful questions about harder projects will reveal who did the work and asking questions appropriate to the applicant will show you understand your team.
This just shows you're a delusional asshole.
One company I know required applicants to do an almost code homework assignment before applying.
When not given something distracting like that interviewers have to think about better topics - and the interview may even become a fun conversation at that point.
It requires a huge deal of self-confidence to be as much effective during an interview as during your lazy sundays.
Most of us will think twice before considering writing the *simplest* statement in front of an interview panel.
Of course you could argue whether good programming abilities are dissociable or not from good social and communication abilities).
Not being able to answer that particular question certainly doesn't preclude someone from being a good programmer.
Why the hell would they need to know that and how does that help you determine that they understand the ASP.
Degree in Computer Science to the table but couldn't understand the concept of a state machine or even building flag values by accumulating bits.
Computer Science classes and that we were allowed to actualy come up with and express ideas all on our own without a professor's approval.
Needless to say he didn't last long.
Actually he was a little on the weird side; he kept coming to work after we fired him.
That concept of being fired seemed beyond him as well.
It has little to do with hoop-jumping and clever tricks and everything to do with getting the job done on a daily basis: some of these people come out of University with a degree and no idea at all how to code.
The company where I work has an extensive series of programming tests for potential new hires including specific problems derived from the kind of coding we expect them to do on a daily basis.
One applicant excused himself to go to the bathroom during the middle of the test and never came back.
For the record: wrote the FizzBuzz thing in under two minutes--right the first time.
In all fairness though I first started programming when I was 15 and that was 31 years ago.
If I can't do FizzBuzz after that amount of time I need to hang up the cape.
Dave Thomas "Code Kata" sense) their craft vs.
In any field there are those who are passionate about what they do and there are those who do it because they need something to do; it's just starting to catch up en masse with technology fields now.
And just because I'm a geek and can't help myself here's what I whipped up in a couple of minutes.
Once there are enough solutions (and optimizations) posted perhaps it can be spun off into the Great FizzBuzz Programming Shootout.
This is an exciting time to be in software development.
Recursion pretty much always uses a stack you're just talking about using a smaller faster stack.
Anyone who expects a VBA programmer to write "swap two variables without using a temp variable" code is going to end up hiring a programmer who gets bored in three months and leaves.
The FizzBuzz problem is a good example of taking a simple set of requirements and translating them into program code.
You might as well ask the interviewee where they bury the survivors when a plane crashes on the border of Canada and the U.
Okay so python's required indenting and blogging don't seem to go well together.
Ah well you all know what I meant.
However if I were hiring someone I'd not make it a prerequisite.
Neither would I fail them if they didn't know what a modulo was.
If they don't know what "this" is then we're screwed.
Instead of using recursion it's often faster to use a Stack.
Yeah but that does not change what I wrote.
Took me all of 30 seconds to do.
That probably won't format properly because HTML is disallowed and there's no preview button.
And now for something completely different.
Eyes light up with passion = Hire on the spot.
Note that the FizzBuzz Test requires at least some simple number theory thinking.
Yes some small children understand it but most people with standard schooling are not comfortable with the ideas of multiples common factors modular arithmetic etc.
But still watch out for hiring *only* super-nerds or your product will be super clever but unusable by "normal" people.
Beware of bugs in the above code.
PhDs do research not programming and I've know dozens of apparently dim graduates turn into excellent developers.
TAUGHT programming at a city college and HE couldn't answer very basic questions about the language.
My typical C++ interview question is to ask whether they understand what happens when an exception is thrown stack unwinding how it can cause memory leaks and what to do about it.
It seems a common complaint that one has to search hard for even basic skills and then harder for someone who will put the effort into being an employee that can be counted on to even show up regularly and actually work.
One wonders what the future holds when you read the above posts realize that a fair number of good programmers will be leaving the market over the next decade (boomers) and hear reports of declining enrollments in the field.
Many of the exciting routines we used to learn just don't apply.
Not sure what kind of educations you have over there but certainly here in Sweden you write A LOT of code if you study computer science on university or college elevel.
The whole thing sounds very strange to me.
Enclosing vector L makes it a scalar which can then be taken as argument of a modulo (primitives in APL requires vectors of same length on each side or a vector and a scalar the latter being applied to each item of said vector).
This gives us a vector of two vectors (one for modulo 3 the other for modulo 5).
In this case : +/(0 0 1 0 0 1 .
Since the result is still a vector of vectors (with only one item) we declose it which makes it a simple vector and assign it to W.
So now we have (0 0 101 0 10 0 .
Since indexing starts from 0 we substract 1 from the vector "¯1+" (- is reserved for substraction ¯ indicates negative numbers : 3-¯1 = 4).
And there you go : Fizz Buzz and FizzBuzz replace multiples of 3 5 or both.
The original post and the original quoted post do nothing except perpetuate the worst stereotype of what a good coder is.
Executive managers prefer to think of their best developers as sweaty grubs who pound the keyboard (rapidly I'm sure) and who amuse themselves with anal debates.
Most of the comments here seem to confirm that stereotype willy-nilly.
Perhaps they became senior programmers by acquiring the habit of quiet reflection *before* pounding the keyboard (rapidly).
Many executives do not understand that the person staring out the window may be getting more done than the busy people at the keyboard.
Job interviews structured to find sweaty grubs will probably find sweaty grubs.
You all are using the wrong language.
The people who couldn't solve the fizzbuzz test you describe in your article might be great at solving well defined problems.
Net but I work daily in several applications (some in-house and some production) and I've been programming now for over a year and a half.
It was very hard at first but I'm becoming more proficient every day.
One day I know I'll be very good but I'm certainly not there yet.
You see I made a career change.
Many of you grew up with computers -- tinkering with them writing programs when you were eight etc.
After years in the military I got out and decided I wanted to challenge myself and become a computer programmer.
So I went to a two-year college got a degree and got my foot in the door at a small software company.
But you know there are plenty of programmers out there who aren't superstars.
They are proficient and reliable and they get the job done.
Just not superstars that eat sleep and breathe programming.
Because some of you might not have hired me and you'd have lost out on a good programmer.
Jeff I like your FizzBuzz question but my use of it in screening would be different since I see an entirely different problem in hiring a programmer.
After she presents a first solution I'd change some requirements crticise some aspect of the code (is a repeated execution of the modulo function needed/efficient don't you know more about the sequence of numbers your processing .
When testing for language competence in my graduate class I have the students write a program at home but then ask them to modify it in class.
While they could cheat and use a "tutor" to write the code at home - if they can't change it and run the resulting program in front of me then there is no way they can code.
This eliminates a lot of the test anxiety stress which affects about 1/4 of the students while accomplishing most of its purpose.
Back in the dark ages when I was a contract programmer for about 6 months the contracting company had a neat way to do a similar test.
They let you get familiar with the system and environment for about a week and then gave you a realistic problem.
If you did it you were still there next week.
BS if they have any kind of computer course and the paper isn't falsified of course they know how to solve that if they don't then you have a serious issue in your education system.
Fizzbuzz problem in a minute - I had a solution in my head before I'd really tried to think about it.
The point is that people go into 'programming' jobs sometimes for the wrong reasons.
Maybe because the money is good.
But these are exactly the kind of folks that need to be encouraged to look elsewhere - and I mean a different career path - for employment.
Encouraging folks with no aptitude for problem solving and logical thinking to work in a field where such an aptitude is needed simply drags down the team.
The problem I've seen in the past is that often those doing the interviews aren't qualified to know the difference between a person in a suit with a smile and a good disposition from a person that will actually be a productive member of an organization.
This is particularly the case in larger organizations I've worked within.
Any organization that doesn't actively try to find the best people deserves what they get in my opinion.
For the sake of curiosity I figured I'd go for the executable line noise version (e.
CS school a decade ago - but the school was a Comptuer Science school - heavy on the science - not a computer engineering school.
Kleene stars and turning machines and all sorts of academic languages that I was unlikely to see again unless I went into computational linguistics.
My token database class spent exactly a week on SQL - and I suppose with reason.
Of course since I graduated I've written SQL pretty much every day of my career.
We spent a lot of time discussing the finer points of various languages spent a lot of effort writing applications that used these finer points but didn't bother to spend much time on "what you would actually use these things for in the Real World.
That fell outside the realm of "CS" again.
Of course on the flip side the IT program at the same school required only the most basic programming classes and a lot of business stuff.
CS gave you all sorts of cool architectural techniques but few basic skills to use them and IT gave you all sorts of practical basics but few techniques.
There was a huge range in the middle where "actual programming" fell that was never addressed.
The only reason I was ever able to hold a job or write some code immediately out of school was because of some hotshot programmer friends who showed me some stuff.
So collegiate education seems to fall short.
From the day I started my post-college career I've been in the minority in every IT department I've ever been in - I'm usually the only person with a formal background in technology.
Many people in your standard corporate IT-development department landed there by accident or by lateral move - their training includes "Teach Yoruself VB4 in 1 Days" or maybe a few classes at the local community college.
OO or even really decent procedural code looks like.
If a developer has never had to solve a problem because a web browser front end lets them get away with it they're never going to think about that problem in the first place.
Maybe this is the "experience" your seeing on people's resumes.
It is interesting that at least two solutions given in the comments are wrong.
Interestingly in the USA (at least in massachusetts where i am from) we used to play the same game but it was called "BizzBuzz" not "FizzFuzz".
But it shows that I can follow the directions and produce code that works.
If the interviewer wants to do a code review and ask me to defend my methodology I'm happy to do so.
Can anyone post the answer to the vowel/even number logic puzzle.
In most languages using a stack instead of recursion speeds up your app tremendously.
Sense Motive roll but I'm truly saddened by the number of people who not only posted the solution but posted the *wrong* solution.
Go back and count the "solutions" that failed to print the values from 1 to 100.
Go back and count the solutions that started a loop at zero instead of one.
In fact my sanity requires that I chose to believe that.
Sure creating your own stack has its own sets of problems and it's not suitable to replace all usages of recursion.
Fortunately coding is merely my hobby.
The one time I applied for a job I did have to do some basic code in front of the owner of the company.
He asked me to do something basic that I hadn't done in C in many years so I couldn't remember the commands so I had to resort to the last language in which I had actually done it: REALbasic.
That was a bit embarrassing to say the least.
Then I optimized it in front of him which I couldn't walk away without doing.
The only thing that won out the other guy in the end was that he had more experience with .
Could very well have been that I was a colossal embarrassment but they were too kind to tell me.
But I do know that I'm glad I didn't get the job.
Geesh I advertise on Craigslist in Austin or Phoenix and over 1/ of the people who apply are able to pass a test like this.
And this is with modest pay for an easy and flexible work at home job (ssh svn etc).
Plus I get maybe 10 to 15 replies running the advertising 1 time and those replies come in within the first 5 days.
So I get 5 to 8 real job candidates and I can focus on long-term aspects of which person is best.
In other words just like writing a good resume is important writing a good job description and knowing where to find people is just as important.
It is interesting that at least two solutions given in the comments are wrong.
Now that I've seen the trick (which isn't a general solution.
It only works for integers and only those containing values that won't overflow when added) I probably would have said "you shouldn't".
Free or Public Domain projects under my belt.
Given that your "correct" answer is something I'd slap someone for trying in any code I have to maintain I think I'd prefer to not get that job anyway.
As for the issue about recursion in my experience most software developers (even fairly good ones) are scared of it.
Its probably a better test of Lisp exposure than anything else.
On the other hand if you are scared of it be honest enough to admit it.
If an algorithm is naturally recursive recursion is probably the best expression of that.
As for the speed issue I agree that a good programmer doesn't do things that are going to be massively slow.
However they also don't pervert their source code for optimization purposes.
If the compiler fails *and* you have a known speed problem *and* you have tracked a big bottleneck down to that chunk of code then you may source-level optimize.
Otherwise just make it as understandable as you can please.
However I would consider "I have trouble with recursion and so does nearly every other developer who will have to maintain this code" a compelling argument.
There were many "write on the board" SQL questions and some Java pair programming with one of the team leaders.
Unfortunately although I nailed the whiteboard part I did poorly on the pair programming portion.
Java well enough and kept foolishly expecting Eclipse to get the case on my variables correct for me leaving off semicolons stuff like that.
It was embarrassing considering that six to eight months previously I had been doing a lot of Java.
Java knowledge a little before the interview but I had an informal offer on the table for a lot more money and was going through with this interview for shall we say domestic political reasons (i.
Because of the pay discrepancy and the awkwardness that would have ensued in trying to negotiate an informal offer against an inferior but formal one I actually dreaded the prospect of an offer.
Some of these tests are fine but I'm sorry.
If they ever need it for some crazy reason they can always use google and spend two minutes learning how to interpret it.
These tests can't determine whether a programmer is economical which is the secret to what actually makes programmers good.
Good programmers get the job done which is why the best test for programmers should be their ability to create stuff (like projects OSS and whatnot).
OO and web-based design concepts.
Nothing particular hard - but worthy of actual thinking.
Then she went and expanded the basics a few times and had me explain what I would do - which covered nicely aspects of software maintenance that I reasonably expect most get to deal with.
Then I think back to another interview where there was a programming test.
And I just completely bombed it .
Well the job was probably too far west (San Francisco) for my family anyway.
But I bet a fair number got home and realized that they could do the task easily under normal conditions but had freaked out with interview anxiety.
While I understand the problem of programmers who can not program I really have no empathy for those of you doing the hiring.
Since college I have taught myself 3 new languages and if I were to interview for a programming job would have brushed up on the syntax enough to have easily passed any of the "tests" listed on this page yet none of you would have let me get that far.
Yet they fall all over each other trying to "catch" one of the kids that used to come to me for help on their assignments week after week.
Because those same kids went on to get a B.
It has been my experience that those who programmers who fail your little tests are most likely failing not because they can't program but because they have a problem applying their knowledge (it is a fine line but a valid one).
Much like most high school grads these days seem to know the basics of proper grammar but could not compose a decent letter to save their lives.
Hopefully a and b aren't near MAX_INTEGER.
In fact this is a worse solution than doing something obviously wrong as it will only come up in the weird cases making it even harder to debug.
VBA job (yes you can stop booing for the peanut gallery) whom I asked to swap two variable contents without using a temp variable.
Well I can't do it in VBA but if you let me use Excel I can put the values in two cells and swap the cells' contents using a third cell.
We hired the guy who said well "if they're integers then I'd do it by a=a|b b=a^b a=a^b.
But I don't know how to do it if they're strings.
After looking up the meaning of the | ^ operators (i.
OR and ^ = bitwise XOR) I attempted a formal proof.
And you can see a swap has not occurred.
India is becoming famous with IT and lot of software development stuff happening here.
Now	reading this article I think my decision is *really* good.
It seems to me that most of the comments here are focused on the actual code solution for the FizzBuzz question.
Most of the best programmers I have ever known including myself do not have a degree of any kind and in my case never went to college.
Yet many companies will simply push your resume aside if they see that you do not have the required degree no matter what you skill level may be.
If companies want to find real programmers with real programming experience they need to broaden their search or have a little slack when it comes to their job requirements.
Note that the FizzBuzz Test requires at least some simple number theory thinking.
The word "multiple" is basic vocabulary and any grown-up with an IQ over 80 ought to be able to understand what it means.
The script below is probably a little inelegant but it works.
Took about 5 minutes but part of that was talking to a co-worker about nasal irrigation.
Mike H the answer to the vowel/even problem is "A" and "3".
It would be all four only if my theory were if-and-only-if but that's not what I specified.
Jeff thanks for posting this one I've found replies really engrossing.
Big Playa - re-read the requirements.
However writing code on a whiteboard is hard even for me and I've written a lot of code in the last 0 years.
These days I'd provide the candidate with a laptop (if they don't have one with them) and watch them code and test their code.
My obfuscation powers are weak this morning I'm sure it could have been done much better.
Incidentally if this were the interviewee's answer I would probably not hire him.
About 8 years ago after a UK conference on teaching the new language of Java one of the attendees said that we certainly needed to change something -- the final year students on the Comp Sci course at his prestigious university were not confident in writing any program even one just 10 lines long.
Other people there agreed that it was not much better if any where they worked.
Surprised I went back to my much less prestigious place where all our students took joint degrees Computing and Maths Computing and History etc and and checked with my final year OO class.
Maybe a culture of 100% attendance and the fact that not being much of a research establishment we did not farm out the practical labs to uninterested grad students.
On recursion I stand by my advice to students.
You should know what it is how it works and how to program it.
But you should _never_ use it in production code because whoever maintains it may not grasp what is going on.
On swapping the values of two variable without involving a third I am torn.
But it does provide a good test to see if someone has read around the subject a bit -- and if they haven't heard of it you could use it like Ben's test to see if their eyes light up when you say it is possible.
Mike Woodhouse - "As I'm about to start looking for a programmer I shall be able to implement my long-cherished plan of asking candidates to submit a page or so of what they consider to be "good code".
And yes I can write the fizzbuzz thing.
HTML applying as a "programmer".
Also knowledge of the framework is beneficial but does not mean you can write a line of useful code.
It means you know how the framework works and frankly that's what docs are for.
It is sort of funny that a lot of people who posted solutions here did not print the actual number on the condition of (i % 3) == (i % 5) == 0.
Toepopper mentioned in his first post and that others have mentioned here.
If that is actually what the interview candidate stated it would have been a bad sign to me a sign that either they'd seen the trick before but didn't understand it or understood the form but not the function (cargo cult).
As others have said though the only time I could ever see this being used is in an embedded system.
Those of you who keep saying that every competent programmer should know this please ask yourselves what it says about _you_ that you can't tell the difference between a simple problem with a mundane solution and a "gotcha" question.
Bottom line - if I ever saw this "clever" trick used in modern non-embedded code I would consider it and everything else around it to be suspect.
That trick is an antique completely irrelevant to today's programming problems (except maybe if you're writing an optimizing compiler).
At least let's make it interesting.
That shows either one of two things you misunderstood the requirements or the even more fatal YOU DIDN'T TEST YOUR CODE.
Also the amount of of bombs we drop on suicidal muslim extremists has no bearing on this topic.
As for outsourcing my old boss when told we needed two more guys for a certain project would say "OK get me 10 indians".
Completely unable to find a good programming job with mine.
The problem is I'm still technically in the clerical position because they won't promote me.
The point of the interview should not be just to find a question that will trip people up.
SELECT statement that deserve that ridicule.
Then again you might be looking for an embedded systems engineer who can do the variable swapping thing and not care if they know SQL.
That is he says "vowel on one side => even number on other".
Unlike most comp sci grads I'd be in it for the fun of problem solving with salary in second place.
Most programmers really can't program.
We give a very simple programming test that basically asks applicants to sort a list of names by first and last name.
Most applicants either totally botch it or end up giving up after four hours or so.
Seriously it has been the best litmus test we could possibly have hoped for.
The difference between skills assessment and sadism is that when you are assessing skills you tell the applicant the answer you were looking for.
Not sharing the answer is intellectual bullying and having been on both sides of the interview table it would make me very leery about a firm that won't answer its own questions.
At my company we use a considerably more complex programming test but we only hire "senior" level type programmers and our job postings specifically state we are looking for senior programmers.
For the java programmers for example we require them to write a webpage that will get data from a database display it let the user edit it and save it.
For C programmers it's an exercise in reading and parsing a data file and generating a report of its contents.
These tests also require knowledge a few non-programming things that are pretty basic to the unix programmer (and we include unix in the job postings so we expect them to know the basics) like telnet and ftp.
Almost all the candidates who take the test literally don't know how to begin.
ONLY used unix and I'm not *that* old - I never had to do punch cards) who don't understand what IP address is don't know how to ftp.
We rarely get anybody who even makes it so far as to be able to begin writing code.
Of the few who make it that far very few of those manage to write anything worthy of consideration.
It takes a looooong time to find acceptable candidates.
Or entertaining depending on your outlook.
And we tell them before they come in that there's going to be a technical test so it's not like it's a surprise when they show up.
And even though they know they don't have any of the technical skills being sought they still show up and waste everybody's time.
The requirements clearly say that for multiples of 3 you are suppose to replace the number and since it is part of the same sentence you can suppose they mean the same for multiples of five.
However multiples of both three and five are a totally different requirement and should be printed in addition to the times the multiples of 3 or 5 are printed.
And I got lost in my pedantics.
You do need to check all 4 cards.
Since if a vowel is on either side you have to have even on the other.
And since anything not a vowel is a consonant and anything not even is odd (ignoring weird cases like "Y" being sometimes one or another) you end up with all 4 cases covered in your theory.
If you have the following set A/ B/ /D 3/D.
You only check the "A" and "3" card and your theory looks good.
You missed it -> Theory wasn't adequately tested.
The US doesn't even have a decent public school system or a decent public healthcare system of course these things have a direct impact on the quality of graduates.
You alone stand for 1/3 of worlds total military spendings and thats with less than 10% of the worlds population.
The US is not what I would call a modern country you may have the gadgets and a great corporate climate but you fail to realize that it's the people that is the country I can give you a million examples of this but that's a completely different discussion.
The military spendings have a LOT to do with the state of your schools today.
All the better if they didn't since it would indicate that they actually read other peoples' code.
Mr Agent will get his/her 10% commission.
However on the other hand there's a difference between not knowing specific code/syntax and not being able to learn it quickly if the need arises.
If you just don't have the mind for the programming then it doesn't matter what language you use: your code is going to be confusing messy and very difficult for anyone else to maintain or build upon.
Prolog to C translator numerous small interpreters major C++ and ksh programs and subsystems many of which are probably still running in systems around the world.
By most standards (faults easy to maintain reusable parts) my code has been excellent.
Although I would not have trouble with the FizzBuzz program I do have trouble producing even some simple programs in 10 minutes while someone waits across the table.
The method is passed a string of characters e.
AABBBBBCCCCDDDEEEEEEEE and it has to return a string holding the longest reocurring character sequence (i.
This is a 10 min exercise which at the time I started it I tested on colleagues to make sure it was reasonable.
You have to allow a lot of leeway for nerves in interviews and some for unfamiliarity with tools but it has been absolutely astonishing how few candidates have been able to complete it in 45 minutes.
Horrible round table generic questions that don't prove to any measurable degree my capabilities as a programmer.
EU doesnt spend its fair share on defence and thus uses the U.
EU can spend money on welfare socialised health and very little on defence.
For example the Canadian Council of Professional Engineers has started to certify Software Engineering as an actual Engineering discipline.
Like Civil Mechanical Electrical etc.
Get a 4-year degree or 5 with co-op.
Spend 4 years under the guidance of other Professional Engineers.
Advance your skills over those four years.
Take a Professional Practice exam.
Have your character vouched for by four existing P.
By the way there's no damned way you'd use that swapping trick on an embedded system.
Second if you try to use cute tricks like that there's a chance that you'll get interrupted in the middle and end up with the wrong values in your two variables.
You can end up writing garbage - sometimes to ports.
The correct answer is "You wouldn't do that.
Yeah it works but it's the worst code in the world.
Chris I haven't seen the card one either but I don't think you have to flip more than A and 3.
So A must be flipped to verify that the other side is even.
You first think "Oh it's even so I have to flip it.
If you see a vowel you have some additional annecdotal evidence to support your theory but nothing that really means anything.
Its wrong to think of solutions from programming perspective.
First we should be able to define the problem & then find the best possible solution.
As for recursion it's good for tree population and list containers.
COBOL implementation of Fizz Buzz here.
Code must be runnable with cut-paste.
In your perl version you could have done this to be more perlish of course.
This response is only to point out the above I'm not criticising or 'correcting' anything.
NOT operand removes unnecessary right side evaluation operators.
The thing that bothers me still about perl is that in my solution the ratio of punctuation vs.
For the guy who wrote the "executable line noise" Perl version: I'm glad you program in Python.
Any comments id be grateful - MattConway@GMail.
My favorite posters are those who lambast others' fizzbuzz programs then go post their own incorrect solutions.
Well you ask a silly question you get a silly answer.
No need to keep a bunch of string arrays around when you're just counting something.
On recursion I stand by my advice to students.
You should know what it is how it works and how to program it.
But you should _never_ use it in production code because whoever maintains it may not grasp what is going on.
Perhaps in a perfect world everyone would be fluent in recursion but in the real world you are likely to be causing maintenance problems for all but an elite few if you use it.
More importantly you are clearly thinking about maintenance issues and teaching to them in class.
If your students graduate and find themselves in a situation you didn't cover in class which they will then at least their heads will be in the right place to start with.
My original problem with the question still holds though.
You have to assume a particular level of precision in writing on the probelm writer.
You might be caught on an off day for that sort of a problem.
Regarding the executable line noise version.
When I professionally worked in perl environments (for about 8 years solid) my perl was quite clean and organised.
Were it not for the excessive perl punctuation you might confuse it with clean Java code.
The only reason that the 's were included is because it is necessary in a for loop.
And yes I agree that 3-level deep nested in-line conditionals are ugly and if I ever found any used in production code within our subversion repository I'd have the person responsible taken out behind the shed and thrashed with a switch.
Your tests do indeed screen out people who cannot code without a computer.
If part of the job requirement is writing coding without a computer then I guess this is a good test.
Most programmers (myself included) write code on a computer and don't have the visualization skills to program on paper.
Whenever I get these questions in an interview I reply that I don't code on paper and if they want an example of my coding they can give me a problem to solve and a computer to solve it on.
As you can see the swap does occur.
Now I have seen lots of programmers that simply were very poor programmers.
It is rare to find a self motivated can-do type of programmer that comes up with a good solution without any coaching.
FizzBuzz though there's something to be said for jumping straight to a pointer/recursion screening question.
Chance of hiring: Unchanged because we've learned nothing useful.
All you need is an algebra with a binary operator and inverse elements[1].
Chance of hiring: Increased (for most jobs).
Now you could argue that for some jobs (say programming at Google) you don't mind losing the competent but mathematically weak programmers in group b.
In that case the scoring matrix is a little better but it still doesn't distinguish between group 1a and group 1b.
If you really want to hire exclusively from group 1b you'd get better results by asking a straight-out math question.
The inverse elements allow you to rewrite "b=a-b" as "b=(-b)+a" which gets rid of the compiler-allocated temporary variable that some architectures require for "b=a-b".
Of course signed C integers aren't closed under addition so you're better off using xor for this trick.
If the target language is C don't fault a guy who hasn't touched C in 3 years and forgot the syntax of a for loop.
If he can show you he knows the key concepts of programming in a procedural language don't reject him out of hand.
If the target language is Prolog or LISP knowing ONLY C or another procedural language may not be a lot of help.
If you need him to be pumping out code at full speed in the first days you need someone who really knows the language now.
If you need full speed within a week you know someone who really knew the language at one time.
With anyone else give them a couple weeks and they'll be up to speed.
This post is like making a comment on a Star Trek forum about the guy in the yellow shirt that dies on the away mission.
Alright well as a current computer science major with 8 years real work experience under my belt I can tell you this: People are persistent.
Some have gone so far as to say that even if you do understand recursion and it makes the best code it's better not to use it for the sake of the idiot they hire to maintain your code.
Every single test I've taken to land a job has been so easy it made me insulted they asked.
In one of my interviews (as a web developer for the Tools department of AOL) they tested me to ensure I knew that GET and POST existed.
They just wanted to know if I knew they existed.
As a web developer I almost assume any applicant would know this just by applying for the job.
That kind of question almost guarantees bitch work.
Instead I went with the interviewer who asked me questions I didnt know.
And sure enough that job gave me more freedom and plenty of good honest to god work experience.
In fact I received 4 internship offers from AOL that summer and two job offers which I turned down.
Some people such as my roomate right now will graduate with near 4.
What a waste of 4 years if you ask me.
Kris you didn't read the requirements x is not printed if anything else is.
They are quite appropriate if you accept a variety of answers; I would take anything that showed the ability and inclination to think.
Fizzbuzz problem logically correct but not worry too much about syntactic details.
It would be better to implement it iteratively.
Or if you insist on recursion you could get O(n) time by using memoization".
THAT is why you ask these questions.
To find the people who can solve problems and propose solutions that you hadn't foreseen.
Sure there is a place for code monkeys who can grab values from a form and stuff them in a database.
But I will MAKE a place for a programmer with insight problem solving skills and a genuine love of their craft.
The xor thing is one little antique trick which is completely and utterly pointless to ask about in an interview.
The fizzbuzz test requires basic programming knowledge of loops which anyone with a CS degree should be able to do.
The Modulus operator would probably be missed by very new programmers but you could still write the loop and test the condition with more code without using the modulus operator although with a code review this code would be optimized to use less lines with the modulus.
If one does give a test it should be only used to gauge overall level of expertise not as the sole basis of hiring.
Net Framework contains 100s to 1000s of classes.
At a previous employer I made a quiz for C# becuase we needed people who had programmed in C#.
It had some questions on the language (framework and Object Oriented questions) as well as a few coding questions.
Nothing too hard (I don't think) but it was comprehensive enough to week out the people with very little experience which is what it was designed to do.
Write a method to add two numbers together.
Now the "test" is more of an interaction between me and the candidate and it becomes more interactive.
At this point it is no longer a programming exercise but becomes more of problem solving exercise.
Something as simple as adding numbers together can tell you alot about a person's programming and problem solving skill.
Recursion is usually illustrated by the Tower of Hanoi problem.
Usually you have to move 8 disks from one pole to another.
The exercise I did was for C++ a few years back and it worked great to move 8 or so disks.
Now just by experimenting with more disks I broke the program.
Additionally I learned that any any recursive code can be solved iteratively.
So this changed my outlook on recursion in general.
Recursion is very clever which produces a solution with very few lines of code but try debugging it when there is a problem.
Clever works in academic environments but I'll take maintainable and supportable over clever any day.
Plus recursion is destined to fail at a certain amount of iterations because there is only so much space on the stack.
Coming to Theater in 008 - Toy Story 4 - Buzz Lightyear and the attack of the FizzBuzzers.
But I am not a programmer just a DBA.
Overall this doesn't surprise me too much.
Well I assume that if you dare to comment with code you solved your *understanding* correctly anyhow.
FizzBuzz test is not because of the test but because it is written.
But mostly there's just the extra hurdle to paper.
You are suddenly required to to keep several complete solutions in your head before you even put pen to paper.
Because I have my pride - I'm not going to give you a stupid solution.
Fizzbuzz really only has one some exclusiveness you need to consider.
Nick Franceschina you rock dude.
Wow Look at all the different languages people have used to do the Fizz Buzz and some have done it poorly.
And this is when the blog(post) by Jeff wasn't even about writing the solution.
That is once you learn a programming language that's actually marketable and get going with the productivity imperative.
Hm I might be getting a bit cynical here.
To me these "observations" sound more like a war stories than anything else.
The kind told by disenchanted employers wishing for affordable "plug'n play" elite programmers they haven't found; or by proud devoted application developers in need of shock therapy.
Otherwise finding good work wouldn't be such a hassle.
Judging by the various ways each of us answered to this post it's clear that we don't all agree about what makes a good programmer for hire.
It seems to depend on the job and mostly on our own background and perceptions.
In my case my personal best bet would be to set up a nice working environment hire bright enough people and let them grow.
Since our profession is being mostly about shifting our understanding from the consumer to the machine from architecture and logic to technology and implementation I would rather build a team with complementary skills rather than give a job to every member of the LISP club who has already built a compiler.
Mechanical types end up and most of the candidates we interview end up knowing nothing of either discipline.
The real lesson here is that how a person looks on paper will rarely reflect their actual abilities.
Write a program that prints the numbers from 1 to 100.
But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”.
For numbers which are multiples of both three and five print “FizzBuzz”.
Then I got a piece of paper and did it.
Really easy of course but I think the interviewers got more information out of that than if I had automatically known how to do it.
VB had a MOD function since I haven't used that since I did Pascal back in college).
This took me about a minute to write if I had more time I would have found out if MOD was better to use.
But it covers the requirements: 1) Loop 1 to 100 ) print FizzBuzz every 15 3) print Buzz every 5 and 4) print Fizz every 3.
And I would have asked the clarification if they supercede each other or if you would need to print Fizz Buzz FizzBuzz every 15.
Sorry Jeff for posting a solution but if you can memorize something like this for a job interview then you can write a loop anyway.
The more shitty programmers there are out there in the world the more in-demand us programmers that can actually think are.
The only thing that is needed is to put the isBuzz and isFizz methods behind some webservice calls then it's the perfect solution.
Computer Science graduating class that could not write a version of this in java/c++ and at least one other language in under 5 minutes.
Sadly the "can't write FizzBuzz" guys end up being promoted more often than not too.
The realities of the modern work place is that it's more important for a programmer to be able to update his milestones in Microsoft Project and draw his designs in Visio that exports to PowerPoint than to actually deliver on his milestones.
There is very much truth to what you said.
In any case here's my two cents in about three minutes (not the only way I know).
You write an insightful post and we all jump on the code quiz.
For production code I'd bother with comments and even a lame test case.
Obviously is so many people do not answer this then there might be something wrong with the question.
The last kind of place I want to work it is one where I am asked to write menial pieces of code at a moments notice without any planning or forethought and have someone look over my shoulder the whole time.
Yes I have a PHD developing hard core quantum meahnics simulation code.
Yes I have managed and coded commercial products that are in the market.
If you want to ask someone to do some work then you should simulate the work environment.
Let them bring in their environment a laptop hook them up to the internet so they have access to all of their resources.
Tell them what you are going to be discussing so they can review what they need to know.
Then ask them to do something non-trivial which actually reflects the job they are being interviewed for.
Beleive it or butt munches not everyone spends their free time memorizing the java syntax or solving high school puzzles.
More importantly and most accurately not every stores and processes information in their mind in the same way.
That does not mean I will be able to recall the information at a momments notice or have the interest in writing code on the blackboard during a conversation.
Yes this is sad but I had to type it up.
CS in my third year to go into the clergy and 13 years later I still was able to write FizzBuzz in C++ in about 4 minutes.
While you guys were so busy frantically coding solutions to the FizzBuzz problem you might've stopped for a moment to consider whether you were going to get owned by the &gt; and &lt; tags.
But be sure to check out my followup *BEFORE* submitting any more code in the comments please.
Once there are enough solutions (and optimizations) posted perhaps it can be spun off into the Great FizzBuzz Programming Shootout.
This is an exciting time to be in software development.
My friend the internet is your huckleberry.
The FizzBuzz programming competition in any language of your choice.
My productivity question lies elsewhere.
Try it and see the horror on the users' faces.
Practice it and see the increase in productivity.
After 10 years writing C in low power embedded systems including a fair bit of interviewing what seems more interesting than asking candidates for a solution to a given problem is to explore their reasoning while arriving at the solution.
Oh and VB isn't a programming language.
Thanks Alan B I wish there were more girls using C it would make the office a much more interesting place to be.
Naturally VB has its place but interviewing for C (or even assembly coding) jobs is so much more fun as there are so many more subtle issues to discuss than in highly abstract languages.
For example above many posters have made statements about 'inefficient code' but nowhere in the design was efficiency stated as a requirement.
To have something extravagant .
Coding has become so abstract that most modern coders tend to be designers due to working with heavily gui based apps from Windows form coding to Web apps.
So we could blame MS for doing this but its not really their fault.
The days of the lone coder are gone most if not all coders have no need to learn or retain any of the stuff they get taught in their college/uni and certainly its not a requirement in a job.
However I think coding should be about architecting a solution and that means working from the ground up.
Coding should be about elegance.
It should be like designing a really well made web page that employs lush CSS and is a visual treat to look at.
Code should be the same well commented and fluid in its layout making the code appealing to read.
Each to their own though every problem has a particular solution however I think what this article was touching on was the fact that the core foundation skills of a coder are not present in most interview cases and this is worrying but I think a growing trend.
When you have hand-holding applications like Visual Studio.
NET there is no real need to retain information as you can for the most part cut and paste your way to a solution.
Oh and VB isn't a programming language.
This monkey does not even know that VB was a huge success for MS.
It is the most successful and productive language alongwith Java.
What is funny to me is how the majority of people who wrote there code on here did the fizz/buzz portion correctly but forgot to print the numbers to screen for the rest.
Maybe the programming world just needs a little attention to detail instilled in them.
It when real world specifications get handed to programmers and the programmers have to spend 80% of the project time getting the specification clarified.
Surely this is a test about reading the question (i.
Writing a program that satisfies your FizzBuzz specification is trivial in any language.
Fizz 4 Buzz Fizz 7 8 Fizz Buzz .
This gives you also the best runtime performance .
The quality of a good programmer is the ability to know how to beg borrow and steal the right code - AND when not to try and solve a problem from scratch.
Write a class to put these items in a linked list.
Having interviewed many so called developers I have come to the conclusion that programming is not necessarily judged *just* on technical skill but on aptitude.
If an interviewee can show understanding of loops\variables\recursion in pseudo code they can be taught the implementation in a given language in a few sessions - I normally take time out to teach any new developer coding standards anyway.
My version starts with "copy con fizzbuzz.
Unfortunately no HTML seemingly means no XSLT.
This program should be run on itself ;-) and of course the square brackets shouldn't be more angular.
At Vertigo we require a code sample before we even proceed to the phone interview stage.
The only thing better would be if the company was required to provide code samples to the interviewee .
One of the things I hate the most is going through an interview where I am grilled on the most obscure nuances of a language the type of things you almost never encounter only to find out after accepting the position that the developers at the company do NOT follow in reality what they preach in the interview.
My productivity question lies elsewhere.
Try it and see the horror on the users' faces.
Practice it and see the increase in productivity.
Working without a mouse is a very unrealistic requirement.
Unless your workplace is really out in the sticks there is no real reason to go without a mouse for more than an hour.
Damn time to take a shower and go to work.
Just for the sake of perversity here's a solution written as a Windows .
But I have written my own 3D game engine.
This is not trivial programming but according to the author of the article I don't know how to program because I can't add in hex or solve a bitwise boolean operation in my head.
Software Engineer doesn't need to know how to solve these problems on a piece of paper.
As a Software Engineer problem solving skills are 80% of software engineering.
The syntax of programming and programming well is the difference between a good programmer and a great programmer.
But as a Software Engineer I do need to know how to find that formula how to implement it in code and where to use it.
Write a function to compute the moving average of a stock price.
Heck I didn't even know what a "moving average" was.
But when I got home I sat down and 0 minutes later I had a nifty little recursive function that answered the question.
Because in the interview I didn't have the resources I would normally have while on the job.
Software Engineer knows how to use those resources to solve programming problems.
Having a CompSci college degree only means that they wasted 4 years (or more) of their lives.
Whereas the self-taught programmers were busy writing software during those 4 years.
And why not test the interviewees on something more pragmatic like create a business object that handles the CRUDs for s simple 3 or 4 property entity (or test them on something else that would be common for your company to write).
So if you ask what a certain does in PHP for instance they'll be able to give you the definition.
So in their mind the "know programming" but they don't know how to put the pieces together.
My friend the internet is your huckleberry.
The FizzBuzz programming competition in any language of your choice.
And all that talent concentrated in one place too.
For all of you self righteous geeks that started your FizzBuzz solutions at 0 your fired (or should I say not hired) because you don't know how to follow instructions.
There is a lot more to programming than some clever implementation in a dozen different languages.
Michael that is creative thinking.
Oh by the way the max of one million was just for benchmarking purposes.
Yes we were comparing implementations.
FizzBuzz problem in most of the language and most of the language i know is C based so maybe i thought make an algorithm/pseudo code maybe that's where most new graduates failed to do or atleast imagine in their heads on how to come up with a solution.
Most of them said 'in your choice of programming languages'.
Well since the friend was the test author and one of the graders I decided I'd do what it said and use an obscure language that pretty much he was probably the only one to ever have seen; the embedded language in most TinyMUSH-derived games.
That was good enough for ME to know that I didn't want to be there.
FizzBuzz in that language a couple minutes of work working the first time with the (stated) assumption that each number's output will be on a separate line.
And obviously people think that it easy to pass an interview even it is not the right job for them (assuming they have a clue that they cannot fulfill the position).
Some of the problem has to do with college.
Most schools are ordeals of initiation especially for undergrads rather then places of learning.
This is especially true for professions like medicine and law where the real acquisition of knowledge starts at the post-graduate level.
Ass Test Death Kick done to me.
Telling him I wrote a '1' did not change his mind.
Shortly after this experience I decided that most universities are a waste of time and decided to go learn things on my own.
It makes you prime fodder for either management or sales.
OK maybe it is just my terminology.
With respect to FizzBuzz if an interviewer ask the question of the phone and the interviewee can understand it recognize that some sort of loop is involved recognize that some sort of logic is inside the loop to determine when to print 'Fizz' and 'Buzz' and is able to communicate this back over the phone in under ten minutes.
Arguing about what language syntax IDE programming best practices etc.
The test is to see if some has at a bare minimum the raw magic required for programming.
We are talking about basic low level questions that weed out the utterly clueless from the *potentially* clued in.
And doing so saves countless hours of the interviewers time.
Your interview question to swap the value of two variables with out using a temp variable is technically impossible.
Just because you don't declare a temp variable the operation a=a+b uses a temp variable created on the fly.
The operation b=a-b uses a temp variable created on the fly.
And the operation a=a-b uses a temp variable created on the fly.
In fact technically three temporary variables are created to perform these three operations.
Buzz application in a plethora of different languages/methods.
And it makes me sad to think that this is the state that programming is in and we wonder why we have software that doesn't work.
Java or C# just change the COUT lines for the output.
As a candidate for a job I always give the following test to the employer.
If one or more of the technical people at the potential employer knows what these acronyms stand for and even better they know what they mean then I will consider working for them.
Never let the interviewer ask all of the hard questions.
But for multiples of three print \"Fizz\" instead of the number and for the multiples of five print \"Buzz\".
For numbers which are multiples of both three and five print \"FizzBuzz\".
As a novice (and I mean brand-spanking new) programmer being given a "challenge" like that is fun.
So I wrote my own little solution to FizzBuzz in C# via ASP.
Even though Jeff's remarks about developers "feverishly posting solutions" is funny I rather liked seeing how others did it.
What really got me confused was trying to figure out what language each poster was using.
The exercises from the book aren't "real" enough.
They ask me to create snippets of code that do something that really isn't useful but it does test to see if I learned the topic from that chapter.
NET that displays a pop-up message when you click the button.
The situation where it's a multiple of 3 AND 5 will fall into the first part of the if and never make it to the i%5==0 && i%3==0 line.
It took me 13 years to get a year degree in Data Processing (they didn't call it "Computer Science" back then).
Basically I am a self taught Software Engineer.
Today I am an independent (currently writing map and delivery software).
They are referred to me by previous clients because of the work I did for them.
So to the employer who hired the geek you probably made a good choice.
Respectfully laughing at your ignorance all the way to the bank.
Now what worries me is that I'm a designer and I could answer to the questions such as FizzBuzz and some dealing with recursion.
Thats why I can't see this as a way to test programmers skills.
FizzBuzz program off the top of my head.
Well the idea of the loop is simple enough however I have NEVER needed to know if a number was divisible by another so I have no idea what function finds that for me.
If I were given the chance to look that part up then I wouldn't have any trouble.
It is shocking how many of the "coders" that posted here did not do simple things like initialize their variables - resulting in code that counts from 0-100 (read that as false positives since 0 mod 3 and 0 mod 5 = 0) - or display ALL numbers INCLUDING multiples of 3 and 5.
Maybe the problem is not so much that most "programmers" can't code but that they can't follow directions.
MSSQL version that improves on the one above by using fewer variables fewer checks and SELECT instead of SET (SELECT is apparently a little faster).
This is what a cobol program used to look like.
First you had your variable declaraction section or something.
Man I can't remember it at all.
AutoCad	000 and enter it into our custom database written in 1988 by a lame-ass who can't program.
By the way I won't be available for comment and I need it done in two weeks.
You can reach me at murpsoft@hotmail.
This could probably be replaced with a list comprehension.
You are making that kind of money have a technical degree call yourself a 'software engineer' have been doing this for years.
Sounds to me like you went into sales a looooong time ago.
But you should not mistake FizzBuzz the great hexadecimal maths question of 007 or any other similar *basic* aptitude/knowledge test as an intelligence metric.
There are plenty of brilliant people out there who cannot program and there are lots of full blow morons who can.
Basically some people have “it” and some don’t…and the correlation with intelligence is weak.
The paper was from a CS academic and was an analysis of his/her students’ performance on an aptitude test that focused on variable assignment concepts.
People interviewing for a position frequently find themselves with 5 50 or even more CVs to consider.
As anyone who’s hired more than a few people can attest to the ‘perfect’ CV does not make a perfect candidate.
We have to look at folks with a wide range of experiences and we have to weed out the time wasters who’ve some how managed to deceive their way into software development.
So we do phone interviews with trivial questions.
CS questions to see if they are a pretender or not.
This could probably be replaced with a list comprehension.
Okay since I ended up posting I'll post the code I jotted down when I read this post.
In a real-world scenario though if code maintainers were not likely to know Perl well I'd probably avoid the trailing-ifs and "unless" because I've seen these things confuse people.
Also parameterizing the input instead of hard coding would possibly be a good way to do it (unless you had to do it in as short a time as possible).
These little extra things (combined with of course a working program) would make you stand out in an interview.
Jeff having 'programmers' attempt to write this type of program in an interview surely will weed out a crap load of candidates.
FizzBuzz program within a couple of minutes on a piece of paper doesn't really mean much either.
From what I can see it only means you understand IF statements and comparison operators.
JavaScript who can pull this program off in 5 minutes but I wouldn't dare consider them for a real programming job.
Well this is just really the tip of the ice-berg.
Which by the way a crap load of people can't do either.
NET Orcas Entity Data Model will significantly reduce the code required for both Fizzing and Buzzing activities.
Additionally you may gain value from the ASP.
NET AJAX Framework which can update your end user's page with Fizzes and Buzzes as they are computed.
Because we all know how high the command is for TI-83 basic.
Far too many comments for me to read through so forgive me if this has already been stated.
Regarding the no-temp-variable swapping: For one I don't think this says anything toward or against anyone's programming ability.
Especially since the solution offered won't work in every case.
The biggest flaw with the plus/minus solution is that overflow can and will occur for large numbers.
The better solution is to use three XOR operations.
And even that obviously wont work for non-numeric variables (strings objects etc).
And it appalls me to see so many people actively not using loops and calculation in the FizzBuzz problem.
If I were hiring a developer and had a candidate that said outright "I don't know" versus a person who did this I'd take the "I don't know" guy/gal.
Important organizations have lost worthy resources because they were asked to hire graduated people just to fulfill requirements for the job's description.
FizzBuzz test can be a good thing but it cannot be the only thing to test a good programmer because some clever minds owners that don't have resources to get a degree may be awaiting for someone to help them launch the rocket then they will take you to mars and venus who knows but If you don't give the chance someone else will do.
Far too many comments for me to read through so forgive me if this has already been stated.
Regarding the no-temp-variable swapping: For one I don't think this says anything toward or against anyone's programming ability.
Especially since the solution offered won't work in every case.
The biggest flaw with the plus/minus solution is that overflow can and will occur for large numbers.
The better solution is to use three XOR operations.
And even that obviously wont work for non-numeric variables (strings objects etc).
And it appalls me to see so many people actively not using loops and calculation in the FizzBuzz problem.
If I were hiring a developer and had a candidate that said outright "I don't know" versus a person who did this I'd take the "I don't know" guy/gal.
Visual Studio 003 + sql server 000 and said you've got 45 minutes here's the sa login.
My impression is that interviewers that give programming tests at best are merely demonstrating that the don't understand human nature and at worst don't actually know how to program themselves.
Created a written form of the test.
Provided a negative incentive such as telling them that their results will be reflected on their next performance review.
This is to provide the ever popular 'under pressure' climate which tests are usually rationalized with.
Required that they do it with no references and no interaction with their co-workers.
Using the results from above process to create what a 'correct' solution looks like and to have some idea of what variances might occur.
If you have done the above then your test actually has some meaning.
If not then you are merely deluding yourself into believing that your test has any objective meaning at all.
The interviewer provided a test which they obviously made up during the interview itself.
It took longer for them to describe the requirements of the test (and to figure them out via my questions) then it did for me to answer it.
The interviewer tested me with a simple code example.
The interviewer became very flustered and was actually somewhat incoherent for the rest of the interview.
One interviewer tested me with an excercise that required GUI knowledge.
GUIs in years and that I wasn't applying for a position that had anything to do with GUIs.
Actually I emphasized that and the interviewer assured me the position didn't need GUIs.
And yet the interviewer still insisted that I needed to attempt the test.
Myself I have found the following (yes I have been responsible for technical interviews in the past.
Given that a candidate passed the above in a positive way then that is all that matters.
However people that can learn and learn from criticism will be more productive in a year than they are now regardless of their ability.
Finally I must mention that all of this completely ignores the fact that interviewers themselves are often incompentent in the interview process.
One interview process (which I was not part of) consisted of two interviewers arguing with each other for 15 minutes while the interviewee was sitting there.
One interviewer couldn't even express questions coherently.
At more that one interview it was very obvious that the interviewers hadn't even read my resume hadn't bothered to even prepare for the interview process and had a significant problem keeping a dialog going.
At one interview within five minutes it became obvious that not only the interviewers (none of them) had bothered to read my resume but apparantly no one else at the company had either.
Ok everybody prepare for the horror as I who has never learned any programming language since the C64 writes fizzbuzz.
Those that enjoy or are any good at it will thrive on attempting to answer the question.
Those that don't enjoy it will just normally sit there staring thinking but not attempting.
Granted these should really be last resort techniques used after a very good initial attempt.
My personal though is that this sort of question should be used solely to see how a candidate approaches the problem.
If they sit there and cry then you know they are unlikely to handle any sort of pressure situation.
If their code is correct but verbose ask them if they can refactor it so that it does the same thing a) more efficiently OR b) with more maintainable code.
You should also present them with a mess of code that does the same thing and ask them to a) work out what it does [understanding others code and methods] and b) spot any errors [debugging other peoples code].
These are the practices that are required by a "developer" (not a programmer) and so long as they understand why they're needed and make a good attempt they're potentially a good candidate.
Granted if we could all write 100% correct code in our head (without a computer) we'd have a world full of wonderful never failing software.
Or has just continued spelling it wrong because they couldn't be bothered to correct it.
Your interview question to swap the value of two variables with out using a temp variable is technically impossible.
See my post above that shows step by step how to do it using XOR.
Since the intermediate results are stored in the variables being swapped no temp variable is required.
FizzBuzz cheat sheet to anyone interested.
You name the language I'll name the price.
No job to small no fee too large.
What I have learned in my few years of solving problems is that the best problem solvers know how to find answers and do not necessarily rely on rote memorization of language syntax.
Test your canidates on ability to find solutions.
If I don't know something I will tell you and if I cannot fathom the answer I will tell you that as well.
But thats me and my problem solvers complex.
MS degree in CS over 5 years as a software engineer several years of teaching graduate students in CS.
My personal opinion is that you can see morons on either side.
Most of these are tricks which don't show candidate's ability to program but show how “smart” the interviewer is.
Of course I do ask them to tell me about it but it's strictly conversational and that's enough.
These are different object models with different objectives.
Still if I have to ask them about coding I suffice with the IF statement.
Its use shows how much you know the boolean basics the functional basics the assignment rules etc.
Most of them don't understand why var = var1.
They never heard of *truth tables* they didn't know how to verify their complex IF statements.
Depends on the chemistry maybe I'll teach him later.
Now about the lousy interviewers.
Yes most of them are like that.
MS Amazon other big companies) conduct the phone interview using lists of predefined questions and answers and the interviewers don't understand anything and if you say something different you loose.
There are others who just want to tickle their ego - they know few algorithmic tricks and ask you to invent that in front of them (if you did not know it beforehand).
Well I usually ask them too – to explain the bubble sort algorithm or something else.
Most of the questions on interviews are on algorithms.
Much more universal and useful is to ask about program structures structured and object oriented programming using unit testing debuggers source safe and other productivity tools.
The process of hiring the right person is complex.
There is luck there is chemistry.
After many years I understood that people work in teams and you should not hire the best knowledgeable programmer but the fittest (to your team) person.
Over here at FogCreek we're working on a few updates to Wasabi for this very purpose so we can compile our FizzBuzz implementation into PHP and VBScript.
In fact I think it would make good sense for us to create a new language specifically for FizzBuzz implmentations on the web.
It has probably been mentioned amongst the code but in my mind there has always been a clear distinction between semantics and syntax in programming.
Semantics is the WHY if our trade Syntax is the HOW.
While this may seem moot it is important to remember that the semantics will always be around while the syntax is ever evolving.
NET Java LISP or Eiffel a FOR loop solves one issue while a recursive call will solve another and the nuances of why they do it are important.
Once you know this hashing it out using the proper terminology becomes moot.
Since web oriented programming/apps (the field I work in) is pushing itself around data parsing/presenting/storing a lot of the tricks that SQL gives us solves the issues for us.
JPL or somewhere else where you're designing the software to respond within a certain time frame to an event.
The speed and resources used could mean life or death out in space and the use of an If/Else vs.
Switch statement means a heck of a lot more.
Eclipse most of your work is done for you.
Give them a challenge out of the norm or for which they don't have resources readily available and then you can see what kind of "programmer" they are.
For readable output add spaces or HTML to taste.
Over here at FogCreek we're working on a few updates to Wasabi for this very purpose so we can compile our FizzBuzz implementation into PHP and VBScript.
Also I apologize for the errors on comment submission.
This is a limitation of Movable Type; it re-renders the entire HTML for the post every time a comment is submitted.
So if two people enter comments at the same time you'll see an error (but your comment *IS* saved).
Half of those who posted the solutions didn't read the questions completely (the fact that you didn't print out the number).
To those who pinch their cents saying that "as long as you can learn new things quickly" I'd say: "good for you" and I'd say: "your 3 hours code XML-oompaloompa must be suck to maintain".
And this came from the audiences of Coding Horror blog.
Amazon interview is quite challenging why don't all of you guys at one point in your life take that interview before you post any code or comment here acting like the "ideal professional programmers" according to "ideal bloggers".
The only ideal developer you would've hired is YOURSELF if this is the case with all the interviewing processes.
As far a recursion goes I think whether you need to use it or not depends on what problems you're solving.
Of course when I did run across the need at least I knew what it was.
Well the site maintainer removed a snippet from my post showing an error from the site; probably for security reasons but it'd been nice to leave an [edited] note.
USELESS when it comes to software engineering/development.
Most profs learned from their profs and so they learned Pascal and VB and Basic.
In real life most people currently use C C++ Java JavaScript and XML.
In university they take two weeks to teach the concept of an array something which I taught (effectively) to a friend in roughly 30 minutes; including looping pointers memory and slicing (which you don't get in university until what.
My prof didn't understand that Java had been programmed in C and is usually really translated when you run javac and JITC'd.
My TA was quite adamant that ASCII has always been 8-bit when in fact it started out from 0-7F and was later extended with high ASCII and then more or less replaced with UTF-8.
They live in their own little world away from real life.
It really pisses me off that companies only hire graduates.
There should be a Profession for Software Engineering.
Science degree is a waste of space.
Math classes and needs more classes geared towards what happens in the real world.
Any real IT guys/programmers in the Industry will tell you that if you want to make the real money - go get an Engineering Degree.
They get paid more get the better positions and have more respect.
Not to mention half the instructors for CS degrees are ancient and need to meet modern reality.
This problem is not necessarily the individuals fault imho it is more down to the education system (in england).
IT course I am doing will not provide me with any practical programming skills.
It will however give me a degree which shows that I can program in C Javascript Java etc.
Just today I had my final C assignment marked.
My code was fine but I lost marks for some omissions in my documentation such as not explaining what I had learnt from the assignment.
This is nice but surprising considering that he wrote a program which in all practicality required a loop without the use of one.
Unfortunately this does not seem to hold any weight as I could get a degree with the highest mark possible without even knowing how to use a FOR loop.
It seems to me that the ability to program is rare because the ability to think about things as a series of steps is so rare.
It seems that those who can do this can code those who can't cannot and there's no hope for them either.
Natural Language Processing" which focused on compiler and writing compilers.
This course was amazing and I have been using the same routines for a wide variety of applications for years.
The most handy tools & techniques were parsing recursion multiple linked lists and trees.
Enclosed is bit of code that is a real test of reading code with recursion.
The code is used to balance an existing binary tree.
MS degree in CS over 5 years as a software engineer several years of teaching graduate students in CS.
My personal opinion is that you can see morons on either side.
Most of these are tricks which don't show candidate's ability to program but show how “smart” the interviewer is.
Of course I do ask them to tell me about it but it's strictly conversational and that's enough.
These are different object models with different objectives.
Still if I have to ask them about coding I suffice with the IF statement.
Its use shows how much you know the boolean basics the functional basics the assignment rules etc.
Most of them don't understand why var = var1.
They never heard of *truth tables* they didn't know how to verify their complex IF statements.
Depends on the chemistry maybe I'll teach him later.
Now about the lousy interviewers.
Yes most of them are like that.
MS Amazon other big companies) conduct the phone interview using lists of predefined questions and answers and the interviewers don't understand anything and if you say something different you loose.
There are others who just want to tickle their ego - they know few algorithmic tricks and ask you to invent that in front of them (if you did not know it beforehand).
Well I usually ask them too – to explain the bubble sort algorithm or something else.
Most of the questions on interviews are on algorithms.
Much more universal and useful is to ask about program structures structured and object oriented programming using unit testing debuggers source safe and other productivity tools.
The process of hiring the right person is complex.
There is luck there is chemistry.
After many years I understood that people work in teams and you should not hire the best knowledgeable programmer but the fittest (to your team) person.
Shame on you for blaming education systems.
Actually sucks to be you guys if you went to podunk college and looking to hire students from that same podunk college.
ANY CODING COMPETITION (Topcoder comes to mind or Google SoC).
You might actually get a solid problem solvers instead of someone who can _JUST_ write C/C++/Java and XML-oompaloompa.
The problem is: you don't know where to look.
That also puts you in a bad situation: incapable of looking decent developers.
Which leads you to an unfortunate complex problem: your company now is filled with not-so good developers because you don't know where to look therefore these top coders won't work there.
And if you get a raw talent teach them mentor them.
Oh and to "The E" I bet your school is a very small school that only gives bachelor degree (or maybe just diploma).
Well in my university profs actually do research.
They came up with AspectJ some fancy mammoth filesystems some fancy Task plugin in Eclipse.
Algorithm used by Starwars movies.
Quit bitching it's your fault to choose such university.
Oh and "The E" Google came up because of those Math equations.
So do some of those Microsoft technologies (Visio PowerPoint to name few).
Though I full well understand the intent of this article I saw the TinyMUSH solution and decided to write one up in MUCK Forth.
Several programmers here have tried the problem but have produced an incorrect answer.
Fortunately the world doesn't revolve around your personal definitions of words.
If you say answering 0x0f + 0x01 is a requirement to meet your definition of a programmer then in your head it is.
The world outside your head goes on without a single thought about who you are or what you believe.
Well in your case that must be true because you have a personal definition of 'great' and that's just.
Some of those people you passed up for not answering 0x10 by law of averages are probably working on projects just as demanding as your projects if not more so making much more than you now (assuming you rejected enough candidates).
And they STILL don't know HEX and the world doesn't care.
Now as for not being able to get FizzBuzz down.
Are you in the top 1% because you can do this ridiculously simple task or are you in the top 99.
Well since the friend was the test author and one of the graders I decided I'd do what it said and use an obscure language that pretty much he was probably the only one to ever have seen; the embedded language in most TinyMUSH-derived games.
That was probably the *LAST* language I expected to see on here.
This blog generated some comments on ISCA BBS so figured we'd all take a crack at it in our preferred (and not-so-preferred) languages.
Kind of pointless unless we are trying to tell all the other coders.
Unit tests are a great test of a programmer/developers skill and I think they should be a requirement for anyone in the modern age.
Why can half of the people here not seem to understand the specs of the prog.
FWIW I tried the sample code above using the XOR and OR and it didn't work for a=3 and b=5.
That use of the binary OR leads me to believe that it'll only work for powers of .
When you hit multiples of 3 and 5 it doesn't print BizzFuzz.
The point of programming FYI is to make a function or group of functions which does something useful.
In my spare time I have created a few QBasic programs which do things like estimate the sine of a value from an infinite sum of square wave calculate the power in the sine wave harmonics of a square wave map points in 3d space to points in d space (like a graphics card) rotate a four-dimensional object etc.
This is all useful (or at least the type of stuff that could be useful).
Making arrays defining functions are all useful things for everything I have done.
They are just one of those unimportant un-needed things that "programmers" learn about.
The VB programmers I know just don't seem to be that involved in what they are doing.
They use VB like they would use Excel.
For the people that said the XOR trick would only work for integers.
It will work for characters as a single character in memory is really an integer in most languages.
For strings you just have to break it down into a character array and use a loop (do/while looking for the null character '\0' at the end of the character array.
Also because of this if you do actual memory swaps using this method it should be possible to do any other datatype/structure/object though you have to be using a language that will allow you to directly manage the memory.
And for the people that don't know the XOR trick (and can't look things up on Google.
This snippet can be put into main or elsewhere.
DEFINE FACTOR1 5 // needs or decreasing performance.
The problems posted there require short programs but most also require a lot of thought.
Depending on the language you use you might have to borrow or write your own large integer class.
Method with one less if statement since 3 and 5 aren't mutually exclusive and variable names.
Speaking as a newly hired entry-level programmer I think this post is completely ridiculous.
FizzBuzz question very quickly (although the logic of it was obvious) but I was recently hired by the IT division of a top I-banking company anyway.
CS major (Math major CS minor).
But they hired me because I'm smart and demonstrably trainable and have passions outside academia.
Basically I represent a low risk.
They can train me however they need to and feel comfortable in the belief that I will be able to contribute.
But the fact that they have to train me is not my fault.
How can an institution like that keep up with all the changes in programming that happen so so fast.
It was "on me" to learn these languages if I needed them for an assignment which was rare.
The only thing I was taught was Java and not very much of it.
However what I WAS taught was theory and architecture.
Heaps stacks linked-lists graphs hash-tables classes inheritence search trees Big-O min-cuts/max-flows database management logic and set-theory optimization and all the basics of data architecture.
This knowledge spans all disciplines within computer science and any language.
Write a function to test if the argument is part of the Fibonacci sequence.
Many candidates don't know where to start.
Most of the times we had to choose the language for the given assignments and also had to give explain why it and not any other during our assignment reviews.
During my degree i used to get frustrated thinking that my friends in other colleges/universities were already talking in C# ASP.
But now i understand the value of it.
Languages can be learnt easily what takes time is developing logic.
Thats what universities must focus on & not on give new technology specialists.
Such candidates usually find it hard to get adapted to new things.
It really is scary when the company I work with is trying to hire guys who know less than the autodidact twelfth grader with only five-years experience.
Heck I could even add a Windows GUI with API for the C++ version with another ten minutes.
THen i was introduced to Borland C and from there became aware of assembly language.
Assembly language became my hobby for a while.
Learn from my mistakes people and if you;re a programmer take every effort to stay on the cutting edge.
BS in computer science about 6 months ago and found this to be very easy to write.
However the point that many graduates are poor programmers is definately true.
PHP Python Ruby JavaScript and have used Bash Awk Sed and Tcl for work in the past.
Not sure if that defines me as a designer or programmer.
By the way because a browser window can have only one window.
THen i was introduced to Borland C and from there became aware of assembly language.
Assembly language became my hobby for a while.
Learn from my mistakes people and if you;re a programmer take every effort to stay on the cutting edge.
Robert Biggs	 I will say designer more then programmer.
However I don't think you can weed them out through simple tests or pedantic questions.
In fact I have seen where really good programmers are either weeded out or just get pissed off at the wasted time and go someplace else.
They said that you could tell because the first few bytes in a compiled Java file say some phrase like "Hot Java" or something.
If so you can hire somebody else.
While I use recursion regularly in code to search a directory tree for specific file-types that I want to parse I can understand that many good programmers have had no need for recursion.
It is simple and any coder should be able to figure out a way to make that happen.
Forgot the blog filters out html tags.
Logo image used with permission of the author.
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>CitrusByte  Ruby TMTOWTDI, Episode 1 </title>
    <meta name="generator" content="Mephisto" />
    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/application.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/css/amy.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/css/slush_poppies.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/css/blackboard.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/css/brilliance_black.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/css/dawn.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/css/lazy.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/css/plastic.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/css/cobalt.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/css/sunburst.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/css/citrus.css" />
    <!--[if IE]><link rel="stylesheet" type="text/css" href="/stylesheets/iehacks.css" /><![endif]-->

    <link href="/feed/atom.xml" rel="alternate" type="application/atom+xml" />
  </head>
  <body class='blog'>
    <div id='container'>
      <div id='header'>
        <div class='redline'>
        </div>
        <div class='citrusbyte'><a href="http://www.citrusbyte.com">home</a></div>
<div class='company'>
  <a href="http://citrusbyte.com/company/overview">company</a>
</div>
<div class='work'>
  <a href="http://citrusbyte.com/work/ripetv">work</a>
</div>
<div class='research'>
  <a href="http://www.citrusbyte.com/research">research</a>
</div>
<div class='blog'><a class="selected" href="http://blog.citrusbyte.com/">blog</a></div>
<div class='contact'>
  <a href="http://citrusbyte.com/contacts/new">contact</a>
</div>
      </div>

      <div class='clear two_col' id='main'>
        
        <div id='bigcol'>
          
  
  <div class="post first">
	  <h1 class="first"><a href="/2008/6/2/ruby-tmtowtdi-episode-1">Ruby TMTOWTDI, Episode 1</a></h1> 
<h2><a href="http://citrusbyte.com/contacts/new">tim</a> on June 2nd, 2008<span><a href="/2008/6/2/ruby-tmtowtdi-episode-1#respond">21 comments</a></span></h2>

<div class="articlebody">

  


  <p>This is the inaugural post in a series that we&#8217;ll be calling Ruby <span class="caps">TMTOWTDI</span> (There&#8217;s more than one way to do it).  Usually the <span class="caps">TMTOWTDI</span> acronym is used as a disparaging term towards flexible languages, which offer a myriad ways of solving most given problems.  This series, however, aims to use this property of Ruby as an educational tool.</p>


	<p>The format is as follows: we&#8217;ll present a problem, then everyone will try and write the most idiomatic, concise code that solves the problem in a readable fashion.  This is not meant to be a golfing competition, nor an optimization one.  However, we will benchmark the solutions for a rough idea on how different styles affect performance. For every installment we&#8217;ll have a performance winner for fastest time and a &#8216;style&#8217; winner for the most elegant code.</p>


	<p>This gives us at CitrusByte a better understanding of each other&#8217;s coding styles, and stimulates discussions about little tricks we may not be aware of. Best of all, it&#8217;s fun as heck to be a part of.</p>


	<p>You can get involved too!  Leave a comment with your solution if you think you can best the ones listed here.  We also encourage you to propose a simple problem (less than 20 lines of code to solve) for the next instalment in the series.</p>


	<p>Since this is the first time we&#8217;re doing it, we&#8217;ve picked a very simple problem to solve as a quick warm-up.</p>


	<p>Problem: given a string &#8216;str&#8217; of the format <pre><code class="citrus"><span class="String"><span class="String">&quot;</span>a10 b20 c25 d40<span class="String">&quot;</span></span>
</code></pre> convert it to a hash <pre><code class="citrus">{<span class="String"><span class="String">'</span>a<span class="String">'</span></span> =&gt; <span class="Constant">10</span>, <span class="String"><span class="String">'</span>b<span class="String">'</span></span> =&gt; <span class="Constant">20</span>, <span class="String"><span class="String">'</span>c<span class="String">'</span></span> =&gt; <span class="Constant">25</span>, <span class="String"><span class="String">'</span>d<span class="String">'</span></span> =&gt; <span class="Constant">40</span> }
</code></pre></p>


	<p>Note that the values of this hash are integers, not strings.  If the string is <pre><code class="citrus"><span class="String"><span class="String">&quot;</span>a10 a20<span class="String">&quot;</span></span>
</code></pre> 
the output should be <pre><code class="citrus">{<span class="String"><span class="String">'</span>a<span class="String">'</span></span> =&gt; <span class="Constant">20</span>}
</code></pre>.</p>


	<p>Leaving some spoiler space in case you want to try it on your own.  Below are selected solutions from our team.</p>


<hr />


	<h2>Spoiler space
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br />
<br /></h2>


<hr />


	<h3>Solutions</h3>


	<h4>Michel</h4>


<pre><code class="citrus"><span class="Support">Hash</span>[<span class="Keyword">*</span>str.<span class="Entity">scan</span>(<span class="String"><span class="String">/</span></span><span class="String"><span class="String"><span class="String">(</span>.<span class="String">)</span></span><span class="String"><span class="String">(</span><span class="Constant">\d</span><span class="String"><span class="String">{</span>2<span class="String">}</span></span><span class="String">)</span></span></span><span class="String"><span class="String">/</span></span>).<span class="Entity">map</span> { |<span class="Variable">k</span>, <span class="Variable">v</span>| [k, v.<span class="Entity">to_i</span>] }.<span class="Entity">flatten</span>]
</code></pre>

	<p>Time taken: 9.99s</p>


	<h4>Tim</h4>


<pre><code class="citrus"><span class="Support">Hash</span>[<span class="Keyword">*</span>(str.<span class="Entity">scan</span>(<span class="String"><span class="String">/</span></span><span class="String"><span class="String"><span class="String">(</span><span class="Constant">\w</span><span class="String">)</span></span><span class="String"><span class="String">(</span><span class="Constant">\d</span>+<span class="String">)</span></span></span><span class="String"><span class="String">/</span></span>).<span class="Entity">map</span> {|<span class="Variable">k</span>, <span class="Variable">v</span>| [k, v.<span class="Entity">to_i</span>] }.<span class="Entity">flatten</span>)]
</code></pre>

	<p>Time taken: 9.40s</p>


	<p>Tim&#8217;s comments: the splat operator has low precedence so the outermost set of
parantheses are redundant, but I felt it&#8217;s better to have them there to make it
very obvious what&#8217;s going on.</p>


	<h4>Nicolas (winner: speed award)</h4>


<pre><code class="citrus">str.<span class="Entity">scan</span>(<span class="String"><span class="String">/</span></span><span class="String"><span class="Constant">\s</span>*<span class="String"><span class="String">(</span><span class="Constant">\D</span>+<span class="String">)</span></span><span class="String"><span class="String">(</span><span class="Constant">\d</span>+<span class="String">)</span></span></span><span class="String"><span class="String">/</span></span>).<span class="Entity">inject</span>({}) {|<span class="Variable">h</span>,(<span class="Variable">k</span>,<span class="Variable">v</span>)| h[k] <span class="Keyword">=</span> v.<span class="Entity">to_i</span>; h }
</code></pre>

	<p>Time taken: 7.19s</p>


	<p>Nicolas&#8217;s comments: I like inject/reduce/fold, whatever you call it. It&#8217;s 
concise and usually a perfect fit for constructing enumerable data structures.</p>


	<h4>Martin (winner: style award)</h4>


<pre><code class="citrus">str.<span class="Entity">split</span>.<span class="Entity">inject</span>({}) {|<span class="Variable">h</span>,<span class="Variable">i</span>| h[i[<span class="String"><span class="String">/</span></span><span class="String">^<span class="Constant">\D</span>+</span><span class="String"><span class="String">/</span></span>]] <span class="Keyword">=</span> i[<span class="String"><span class="String">/</span></span><span class="String"><span class="Constant">\d</span>+$</span><span class="String"><span class="String">/</span></span>].<span class="Entity">to_i</span>; h }
</code></pre>

	<p>Time taken: 8.75s</p>


	<h4>Ari</h4>


<pre><code class="citrus">hash <span class="Keyword">=</span> str.<span class="Entity">split</span>.<span class="Entity">inject</span>({}) <span class="Keyword">do </span>|<span class="Variable">set</span>, <span class="Variable">h</span>|
  set.<span class="Entity">merge</span>( {h[<span class="Constant">0</span>].<span class="Entity">chr</span> =&gt; h[<span class="Constant">1</span>..<span class="Keyword">-</span><span class="Constant">1</span>].<span class="Entity">to_i</span>} )
<span class="Keyword">end</span>
</code></pre>

	<p>Time taken: 23.02s</p>


	<p>Ari&#8217;s comments: I knew everyone else would be strutting their one-liners, so I went for as much clarity as possible.  I feel this code not only solves the problem, but also makes it very apparent what the desired solution is.</p>


	<h3>Benchmark code</h3>


<pre><code class="citrus"><span class="Keyword">require</span> <span class="String"><span class="String">'</span>benchmark<span class="String">'</span></span>

<span class="Variable">ITERATION</span> <span class="Keyword">=</span> <span class="Constant">400</span>

<span class="Keyword">def</span> <span class="Entity">measure</span>(<span class="Variable"><span class="Keyword">&amp;</span>block</span>)
  <span class="Variable">ITERATION</span>.<span class="Entity">times</span> { block.<span class="Entity">call</span> }
<span class="Keyword">end</span>

str <span class="Keyword">=</span> <span class="String"><span class="String">'</span><span class="String">'</span></span>
<span class="Constant">5000</span>.<span class="Entity">times</span> { str <span class="Keyword">&lt;&lt;</span> (<span class="String"><span class="String">'</span>a<span class="String">'</span></span>..<span class="String"><span class="String">'</span>z<span class="String">'</span></span>).<span class="Entity">to_a</span>[<span class="Entity">rand</span>(<span class="Constant">26</span>)] <span class="Keyword">+</span> (<span class="Entity">rand</span>(<span class="Constant">90</span>)<span class="Keyword">+</span><span class="Constant">10</span>).<span class="Entity">to_s</span> <span class="Keyword">+</span> <span class="String"><span class="String">'</span> <span class="String">'</span></span> }
br <span class="Keyword">=</span> <span class="Support">Benchmark</span>.<span class="Entity">bmbm</span> <span class="Keyword">do </span>|<span class="Variable">b</span>|
  b.<span class="Entity">report</span>(<span class="String"><span class="String">&quot;</span>Running <span class="String"><span class="String">#{</span><span class="Variable">ITERATION</span><span class="String">}</span></span> times on string of length <span class="String"><span class="String">#{</span>str<span class="String"><span class="String">.</span><span class="Entity">length</span></span><span class="String">}</span></span><span class="String">&quot;</span></span>) <span class="Keyword">do</span>
    measure {
<span class="Comment">      <span class="Comment">#</span>### Code to measure goes here</span>
    }
  <span class="Keyword">end</span>
<span class="Keyword">end</span>
</code></pre>

	<h3>Conclusion</h3>


	<p>Lots of interesting styles here.  We have two ways of creating hashes: with the <code class="citrus"><span class="Support">Hash</span>[ [key =&gt;<span class="Keyword">|</span>, value]<span class="Keyword">*</span> ] 
</code> method and with <code class="citrus"><span class="Entity">inject</span>()
</code>.  We&#8217;ve also seen various ways of breaking up a string: with <code class="citrus"><span class="Entity">scan</span>()
</code>, with <code class="citrus"><span class="Entity">split</span>()
</code>, and with regex arguments to a string&#8217;s <code>[]</code> method.  While we cannot come to definite conclusions about performance (since the code that is being compared doesn&#8217;t differ just in one area), we can see a couple things going on:</p>


	<ul>
	<li>running Hash[] on an array as opposed to creating it directly via inject hurt Michel and Tim&#8217;s performances compared to Martin/Nicolas</li>
		<li>merge() seems to be significantly more costly than straight addition/replacement of hash keys. If you&#8217;re ever injecting into a hash it may be wiser (if your problem allows) to follow the <code class="citrus">{ hash[key] <span class="Keyword">=</span> value; hash }
</code> format instead of merging.</li>
	</ul>


	<p>We&#8217;ve picked Martin as the style winner for the elegance of his code&#8212;which fit of the string parsing inside the inject block as opposed to the scan-based solutions which did some of it outside in the scan.  The <code class="citrus">h[i[<span class="String"><span class="String">/</span></span><span class="String">^<span class="Constant">\D</span>+</span><span class="String"><span class="String">/</span></span>]] <span class="Keyword">=</span> i[<span class="String"><span class="String">/</span></span><span class="String"><span class="Constant">\d</span>+$</span><span class="String"><span class="String">/</span></span>].to_i
</code> portion was the clearest signal of intent for the contents of the hash.</p>


	<p>Meanwhile, Nicolas is the performance winner by a mile, coming in more than 20% faster than the nearest competitor.</p>


	<p>Congratulations to Martin (style) and Nicolas (speed) for being the winners of the inaugural CitrusByte Ruby <span class="caps">TMTOWTDI</span>.  Stay tuned for the next episode!</p>


	<h3><span class="caps">EDIT</span></h3>


	<p>Additional comments by Nicolas:</p>


	<p>Anyway, after thinking about it, even if I like inject a lot, there&#8217;s one big gain for the Hash[*...] as Michel posted. It
transmits intent better, in a way.</p>


	<p>You look at that and the entire code sequence is a Hash construction, plain and simple, even if you ignore the subexpression in the middle, you know the outcome. And if you look one character into the brackets, then you know it&#8217;s constructing a hash from some transformation of an existing enumerable. Bah, just something that responds to #to_a.</p>


	<p>Instead, using inject, the code flows (at least in my head) nicer &#8211; as you don&#8217;t have to parse subexpressions, but it&#8217;s not immediately obvious what&#8217;s it about.</p>


	<p>Hm, actually, depends on what intent is better to show. I mean, the objective is something like &#8220;to transform a string in a certain format into a more traversable structure&#8221; or &#8220;to create a hash out of a string in a certain format?&#8221;</p>


	<p>That (not so) subtle difference might make me decide about which way is better, but then the description of the problem is not descriptive enough. Good, that means that the problem lies in the exercise&#8217;s designer. I can sleep well :P</p>


	<p>(Probably there&#8217;s a third approach that to a degree involves a recursive lambda and someone flying over a desktop yelling &#8220;stand back! I know hash construction&#8221;, but my ninjitsu is not good enough for that yet)</p>


	</div>
	
	<div class="entrymeta">
  	<div class="postinfo">
  		<span class="filedto"></span>
  	</div>
  </div>
  
	
    <div id="commentsblock">
      
	<h2>21 Comments</h2> 
	<ul class="commentlist">
	
		<li class="alt" id="comment-140">
			<div class='commentmeta'><span><a href="http://citrusbyte.com">Michel</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>The fastest approach I've found so far:</p>

<p>hash = Hash.new; str.scan(/(\w)(\d\d)/).each { |k, v| hash[k] = v.to_i }</p></div>			
		</li>
  
		<li class="" id="comment-141">
			<div class='commentmeta'><span><a href="http://www.michaelboutros.com/">Michael Boutros</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>This is what I'd do, takes less than 0.1 seconds using your benchmark code: </p>

<p>hash = {}; str.split.each {|str| hash.merge!({str[0, 1] => str[1, 2].to_i})}</p></div>			
		</li>
  
		<li class="alt" id="comment-142">
			<div class='commentmeta'><span><a href="http://www.lukeredpath.co.uk">Luke Redpath</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>Here's a first attempt at a one-liner without looking at other answers:</p>

<p>Hash[*str.split(/\s/).map { |token| 
  token.match(/(\D+)(\d+)/) 
}.inject([]) { |arr, match| 
  arr &lt;&lt; match[1] &lt;&lt; match[2].to_i 
}]</p></div>			
		</li>
  
		<li class="" id="comment-143">
			<div class='commentmeta'><span><a href="http://www.lukeredpath.co.uk">Luke Redpath</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>Also, if you didn't need the values to actually be integers, Michel's solution could be condensed into:</p>

<p>Hash[*str.scan(/(\D+)(\d+)/).flatten]</p></div>			
		</li>
  
		<li class="alt" id="comment-144">
			<div class='commentmeta'><span><a href="http://www.lukeredpath.co.uk">Luke Redpath</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>Duh, the above example doesn't account for the spaces, this one does:</p>

<p>Hash[*str.scan(/(\D+)(\d+)\s?/).flatten]</p></div>			
		</li>
  
		<li class="" id="comment-145">
			<div class='commentmeta'><span><a href="http://nicolassanguinetti.info">Nicolás Sanguinetti</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>Actually seeing all the solutions, my regexp is horrible :P I should've used \w instead of \D. And besides that's even faster. The benchmark in my computer for my original solution reports 7.08s, and for the same approach (str.scan, then inject) but using Tim's regular expression times at 6.45s</p>

<p>Not that I care that much for speed over readability, but in this case the regular expression is actually clearer, and even faster to parse! :)</p>

<p>I can't wait for episode II ^_^</p></div>			
		</li>
  
		<li class="alt" id="comment-146">
			<div class='commentmeta'><span><a href="http://nicolassanguinetti.info">Nicolás Sanguinetti</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>Oh, and Michel's fastest solution (first comment) times at 4.98s in my computer, so it's still the fastest solution around.</p></div>			
		</li>
  
		<li class="" id="comment-147">
			<div class='commentmeta'><span><a href="http://www.progprog.com">Tim Goh</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>Nicolas, are you just trying to show that your computer is faster than mine?  =P</p></div>			
		</li>
  
		<li class="alt" id="comment-148">
			<div class='commentmeta'><span><a href="http://www.michaelboutros.com/">Michael Boutros</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>My new method: </p>

<p>hash = Hash.new; str.split.each {|str| hash[str[0, 1]] = str[1, 2].to_i}</p>

<p>Calling Hash.new directly didn't really change anything, but replacing #merge! with a direct replace/add made a difference. However, the script went from 0.0018 (real) to 0.0016 (real), so not a big deal.</p>

<p>I think the main difference between my solution and all the others is the use of a regular expression. In this case, we know that the first character will <em>always</em> be the key, and the next two characters will <em>always</em> be the value. Because the pattern will never change, isn't running the expression a bit too costly? </p></div>			
		</li>
  
		<li class="" id="comment-149">
			<div class='commentmeta'><span><a href="http://www.progprog.com">Tim Goh</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>Michael and Luke, thanks for your thoughts!  </p>

<p>Yeah the point of requiring integers was to make it a slightly more involving problem. Requiring integers would entail more variations of answers since you'd need a way of iterating for the to_i.</p>

<p>I generally tend to favor regexes (despite performance hits over straight-up string indexing) because most of the time they communicate intent more.</p></div>			
		</li>
  
		<li class="alt" id="comment-151">
			<div class='commentmeta'><span><a href="http://lucumr.pocoo.org/">Armin Ronacher</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>Another possibility would be something like this:</p>

<p>str.split.inject({}) {|h, s| h[s.slice!(0).chr] = s.to_i; h }</p>

<p>In 1.9 it would look a bit nicer:</p>

<p>str.split.inject({}) {|h, s| h[s.slice!(0)] = s.to_i; h }</p>

<p>(The latter is untested)</p></div>			
		</li>
  
		<li class="" id="comment-152">
			<div class='commentmeta'><span><a href="http://lucumr.pocoo.org/">Armin Ronacher</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>Here another possibility:</p>

<p>Hash[*str.split.inject([]) {|a, s| a &lt;&lt; s.slice!(0).chr &lt;&lt; s.to_i }]</p></div>			
		</li>
  
		<li class="alt" id="comment-153">
			<div class='commentmeta'><span><a href="http://lucumr.pocoo.org/">Armin Ronacher</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>Grr. Stupid me. slice can return strings for real slices.  So that one would work too:</p>

<p>Hash[*str.split.inject([]) {|a, s| a &lt;&lt; s.slice!(0, 1) &lt;&lt; s.to_i }]</p></div>			
		</li>
  
		<li class="" id="comment-154">
			<div class='commentmeta'><span><a href="http://potatosaladx.blogspot.com/">Andrew Bennett</a></span> on June 2nd, 2008:</div>
			<div class='commentbody'><p>Here's mine, I tested it on two separate machines and it's about 1 second faster than Nicolas's method.</p>

<p>Ugly one-liner form:</p>

<p>require 'enumerator'; h = Hash.new; str.unpack('aa2x' * (str.length / 4)).each<em>slice(2) { |(k,v)| h[k] = v.to</em>i }; h</p>

<p>Slightly better multi-line form:</p>

<p>require 'enumerator'
h = Hash.new
str.unpack('aa2x' * (str.length / 4)).each<em>slice(2) { |(k,v)| h[k] = v.to</em>i }
h</p>

<p>Here's the averages I got from the first machine I tested it on:</p>

<p>Martin:  19.71
Nicolas: 14.09
Andrew:  13.26</p>

<p>And the second machine:</p>

<p>Martin:  7.62
Nicolas: 5.60
Andrew:  4.17</p>

<p>It's probably cheating to require a separate module from stdlib, but you didn't specify whether I could or not in the requirements :-)  Personally, I had never used the Enumerable#each_slice method before.</p></div>			
		</li>
  
		<li class="alt" id="comment-155">
			<div class='commentmeta'><span><a href="http://moose56.com">David Madden</a></span> on June 3rd, 2008:</div>
			<div class='commentbody'><p>A great post, I love these as its always a good way to pick up tips.</p>

<p>This is especially interesting looking into the dark art of creating hashes using blocks.</p></div>			
		</li>
  
		<li class="" id="comment-156">
			<div class='commentmeta'><span><span>john</span></span> on June 3rd, 2008:</div>
			<div class='commentbody'><p>I suppose these things are system dependeent. I tried the supplied methods and all were clocking in around the 25-30 seconds mark (Yes, I have a slow machine).</p>

<p>Applying a little KISS to the idea I came up with the very simple:</p>

<pre><code>    output  = Hash.new
    inter   = Array.new
    inter   = str.split

    inter.each do |s|
        output[s[0,1]] = s[1,3].to_i
    end
</code></pre>

<p>Which clocked in around 12 secs on my machine. It seems that forcing the types might help the compiler instead of making it choose.</p>

<p>Interesting test though.</p></div>			
		</li>
  
		<li class="alt" id="comment-157">
			<div class='commentmeta'><span><a href="http://rpheath.com">Ryan</a></span> on June 3rd, 2008:</div>
			<div class='commentbody'><p>Here's one more:</p>

<pre>
s.split.sort.inject({}) { |h, a| h.merge(a[/^[a-z]/] => a[/[0-9]+$/].to_i) }
</pre>

<p>I could be wrong, but I don't think "a20".to<em>i results in 20. I believe, if the number is first, doing a to</em>i on a string will return the number. But when the letter is first, that's not the case, which means that there still needs to be some sort of parsing, rather than a v.to_i implementation, right?</p>

<p>Again, maybe I'm wrong about that.</p></div>			
		</li>
  
		<li class="" id="comment-158">
			<div class='commentmeta'><span><a href="http://potatosaladx.blogspot.com/">Andrew Bennett</a></span> on June 4th, 2008:</div>
			<div class='commentbody'><p>Whoops, I hadn't read all of the comments yet when I submitted my post.  I thought Nicolás said that Martin's was 4.98 seconds.</p>

<p>I went ahead tested some of the faster implementations to see who came out winner on my two systems.</p>

<p>The first system is a AMD Athlon XP 2400+ with 2.5GB of RAM running "Linux 2.6.24-17-generic i686" (Ubuntu 8.04)</p>

<pre>
Andrew:   13.26
Armin #1: 11.45
Armin #2: 15.56
John:      8.81
Luke:     30.18
Nicolás:  14.09
Martin:   19.71
Michel:   10.33
Ryan:     52.45
</pre>

<p>The second system is an Intel Xeon 5130 @ 2.00GHz with 2GB of RAM running "FreeBSD 7.0-RELEASE amd64"</p>

<pre>
Andrew:   4.17
Armin #1: 4.98
Armin #2: 5.43
John:     3.86
Luke:     9.88
Nicolás:  5.60
Martin:   7.62
Michel:   4.01
Ryan:     21.33
</pre>

<p>For some reason, Armin's first implementation is faster than mine on 32-bit Linux, while mine is faster than his on 64-bit FreeBSD.</p>

<p>John's implementation still mops the floor with the rest of us.</p></div>			
		</li>
  
		<li class="alt" id="comment-161">
			<div class='commentmeta'><span><a href="http://dkoontz.wordpress.com">David Koontz</a></span> on June 4th, 2008:</div>
			<div class='commentbody'><p>My (without looking) solution was pretty similar to Nick's although I didn't assume the key would always be a single character.</p>

<p>str.split.inject({}) {|hash, item| item =~ /(\w+?)(\d+)/; hash[$1] = $2.to_i; hash}</p>

<p>Something strange I noticed was the parentheses around two of the block parameters in Nick's solution.  I removed them and to my surprise it had a drastic impact on performance.</p>

<p>With parentheses: 6.66
Without parentheses: 8.45</p>

<p>I got similar result with JRuby. Can anyone explain what the presence of parentheses in the argument list even does and how that might be impacting performance?</p></div>			
		</li>
  
		<li class="" id="comment-166">
			<div class='commentmeta'><span><a href="http://patnakajima.com">Pat Nakajima</a></span> on June 5th, 2008:</div>
			<div class='commentbody'><p>Great post! I look forward to more of these.</p></div>			
		</li>
  
		<li class="alt" id="comment-167">
			<div class='commentmeta'><span><a href="http://nicolassanguinetti.info">Nicolás Sanguinetti</a></span> on June 5th, 2008:</div>
			<div class='commentbody'><p>@David: The parentheses are there to unpack the second item into (k, v) instead of having to split it inside, I didn't know it would give an improvement on performance.</p>

<p>@Andrew: Michel's "quickest version" (the one posted in the first comment) run in 4.98 seconds in my machine, one of the new penryn MacBook Pros (2.4GHz Core 2 Duo, 2GB @667 stock)</p></div>			
		</li>
  
	</ol>





<div class="clear">
  <h3 id="respond">Add a comment</h3>
  <form id="comment-form" method="post" action="/2008/6/2/ruby-tmtowtdi-episode-1/comments#comment-form">
    <p><input type="text" id="comment_author" name="comment[author]" value="" /><label for="author"><small>Name (required)</small></label></p>
    <p><input type="text" id="comment_author_email" name="comment[author_email]" value="" /><label for="email"><small>Mail (will not be published)</small></label></p>
    <p><input type="text" id="comment_author_url" name="comment[author_url]" value="" /><label for="url"><small>Website</small></label></p>
    <p><textarea name="comment[body]" id="comment" cols="50%" rows="10"></textarea></p>
    <p><input name="submit" type="submit" id="submit" value="Submit Comment" /></p>
  </form>

  
</div>
    </div>
  
  </div>



        </div>
        
        <div class='col' id='sidebar'>
          <h3>Search</h3>
<form method="get" id="sform" action="/search">
	<input type="text" id="q" value="" name="q" size="25" />
</form>
<h3>Links</h3>
<ul>
  <!-- <li><a href="/">Home</a></li><li><a href="/rails">Rails</a></li><li><a href="/ruby">Ruby</a></li><li><a href="/code">Code</a></li><li><a href="/tutorials">Tutorials</a></li><li><a href="/free-stuff">Free Stuff</a></li> -->    
  <li><a href="http://willjessup.com/">Will Jessup</a></li>
  <li><a href="http://blog.xnot.org/">Ari Lerner</a></li>
  <li><a href="http://www.danielfischer.com/">Daniel Fischer</a></li>
  <li><a href="http://deadprogrammersociety.blogspot.com/">Ron Evans</a></li>
  <li><a href="http://www.rubyinside.com/">Ruby Inside</a></li>  
  <li><a href="http://www.progprog.com/">Tim Goh</a></li>
</ul>
<ul>
<li><a href="http://technorati.com/faves?sub=addfavbtn&amp;add=http://blog.citrusbyte.com"><img src="http://static.technorati.com/pix/fave/btn-fave2.png" alt="Add to Technorati Favorites" /></a></li>
<li><a href="http://feeds.feedburner.com/Citrusbyte-Home" rel="alternate" type="application/rss+xml"><img src="http://www.feedburner.com/fb/images/pub/feed-icon16x16.png" alt="" style="vertical-align:middle;border:0"/></a></li>
<li><p><a href="http://add.my.yahoo.com/rss?url=http://feeds.feedburner.com/Citrusbyte-Home" title="CitrusByte - Home"><img src="http://us.i1.yimg.com/us.yimg.com/i/us/my/addtomyyahoo4.gif" alt="" style="border:0"/></a></p></li>
</ul>
        </div>      
   
        <div class='clear' id='footer'>
          <a href="/"><img alt="Mini c" src="/images/mini_c.gif"/></a>
          <div class='copy'>&copy; 2008 CitrusByte LLC. All Rights Reserved.</div>
          <div class='link'><a href="/">Back to Blog</a></div>
        </div>
        
      </div>
    </div>
  </body>
  <script type="text/javascript">
  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
  </script>
  <script type="text/javascript">
  var pageTracker = _gat._getTracker("UA-2672159-1");
  pageTracker._initData();
  pageTracker._trackPageview();
  </script>
<script type="text/javascript">
var bt_counter_type=1;
var bt_project_id=11690;
</script>
<script type="text/javascript" src="http://tracker.icerocket.com/services/collector.js"></script>
</html>